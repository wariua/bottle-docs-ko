
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>개발자를 위해 &#8212; Bottle 0.12.18 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="플러그인 개발 안내서" href="plugindev.html" />
    <link rel="prev" title="릴리스 노트와 변경 로그" href="changelog.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1>개발자를 위해<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>보틀 개발과 릴리스 작업에 관심 있는 개발자와 패키지 제작자를 위한 문서다. 기여하고 싶다면 언제든 환영이다!</p>
<div class="section" id="id2">
<h2>참여하기<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>공통체에 참여해서 최신 소식을 받을 수 있는 방법이 여러 가지 있다. 다음이 그 중 일부다.</p>
<ul class="simple">
<li><p><strong>메일링 리스트</strong>: <a class="reference external" href="mailto:bottlepy+subscribe&#37;&#52;&#48;googlegroups&#46;com">bottlepy+subscribe<span>&#64;</span>googlegroups<span>&#46;</span>com</a>로 이메일 보내서 메일링 리스트에 가입. (구글 계정 필요 없음.)</p></li>
<li><p><strong>트위터</strong>: <a class="reference external" href="twitter.com/bottlepy">트위터에서 팔로우</a> 하거나 <a class="reference external" href="https://twitter.com/#!/search/%23bottlepy">#bottlepy</a> 태그 검색.</p></li>
<li><p><strong>IRC</strong>: <a class="reference external" href="irc://irc.freenode.net/bottlepy">irc.freenode.net의 #bottlepy</a> 가입하거나 <a class="reference external" href="http://webchat.freenode.net/?channels=bottlepy">웹 채팅 인터페이스</a> 이용.</p></li>
<li><p><strong>구글 플러스</strong>: 가끔씩 Google+ 페이지에 <a class="reference external" href="https://plus.google.com/b/104025895326575643538/104025895326575643538/posts">보틀, 릴리스, 기술적 내용에 대한 글</a>이 올라간다.</p></li>
</ul>
</div>
<div class="section" id="id6">
<h2>소스 받기<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>보틀 <a class="reference external" href="https://github.com/defnull/bottle">개발용 저장소</a>와 <a class="reference external" href="https://github.com/defnull/bottle/issues">이슈 트래커</a> 모두 <a class="reference external" href="https://github.com/defnull/bottle">github</a>에 있다. 기여를 할 생각이라면 거기 계정을 만들어서 주 저장소를 포크 하는 방식이 좋다. 그러면 변경 내용과 아이디어를 다른 개발자들이 보면서 함께 토론할 수 있다. 계정이 없어도 저장소를 복제하거나 최신 개발 버전을 소스 아카이브로 다운로드 하는 건 가능하다.</p>
<ul class="simple">
<li><p><strong>git:</strong> <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">clone</span> <span class="pre">git://github.com/defnull/bottle.git</span></code></p></li>
<li><p><strong>git/https:</strong> <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">clone</span> <span class="pre">https://github.com/defnull/bottle.git</span></code></p></li>
<li><p><strong>다운로드:</strong> 개발 브랜치를 <a class="reference external" href="http://github.com/defnull/bottle/tarball/master">tar 아카이브</a> 또는 <a class="reference external" href="http://github.com/defnull/bottle/zipball/master">zip 파일</a>로.</p></li>
</ul>
</div>
<div class="section" id="id9">
<h2>릴리스와 업데이트<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>보틀은 비정기적으로 릴리스 되고 <a class="reference external" href="http://pypi.python.org/pypi/bottle">PyPI</a>를 통해 배포된다. 릴리스 후보 버전과 과거 릴리스의 버그 수정 버전은 위에서 말한 git 저장소에서만 얻을 수 있다. 다만 일부 리눅스 배포판에서 과거 릴리스의 패키지를 제공할 수도 있다.</p>
<p>보틀 버전 번호는 세 부분(<strong>major.minor.revision</strong>)으로 이뤄져 있다. 버전 번호의 용도는 새 기능을 알리는 게 <em>아니라</em> 중요한 버그 수정 및/또는 API 변경을 나타내는 것이다. 중대한 버그는 최근의 최소 두 개 마이너 릴리스에서 수정이 이뤄지며 가능한 모든 채널(메일링 리스트, 트위터, github)로 알린다. 중대하지 않은 버그나 기능은 백포트를 보장하지 않는다. 다만 이는 나중에 바뀔 수 있다.</p>
<dl class="simple">
<dt>메이저 릴리스 (x.0)</dt><dd><p>중요한 마일스톤이나 하위 호환성을 완전히 깨는 업데이트에서 메이저 번호를 올린다. 새 릴리스를 이용하려면 아마 응용 전체에 작업을 해 줘야 할 것이다. 하지만 이 릴리스는 아주 드물다.</p>
</dd>
<dt>마이너 릴리스 (x.y)</dt><dd><p>API나 동작이 어떤 식으로든 바뀌는 업데이트에서 마이너 번호를 올린다. 폐기 예정 경고를 보게 될 수도 있고 이전 동작 방식을 살리기 위해 설정을 좀 건드려야 할 수도 있지만 대부분의 경우 그런 변화는 적어도 마이너 릴리스 한 개에 대해선 하위 호환성이 있도록 설계된다. 업데이트 해서 최신으로 만드는 게 좋지만 필수는 아니다. 0.8은 예외인데, 하위 호환성을 완전히 깼다. (그래서 0.7을 건너뛰었다.) 그렇게 돼서 유감이다.</p>
</dd>
<dt>리비전 (x.y.z)</dt><dd><p>버그 수정, 또는 API나 동작을 바꾸지 않는 기타 패치에서 리비전 번호를 올린다. 응용 코드를 편집할 필요 없이 안전하게 업데이트 할 수 있다. 실제로는 되도록 빨리 업데이트 하는 게 좋다. 중요한 보안 문제 수정이 이 방식으로 릴리스 되기 때문이다.</p>
</dd>
<dt>릴리스 전 버전</dt><dd><p>릴리스 후보는 리비전 번호에 <code class="docutils literal notranslate"><span class="pre">rc</span></code> 표시가 붙어 있다. API가 거의 안정적이고 테스트 준비가 되었지만 아직 공식적으로 릴리스 되지는 않은 버전이다. 운용 환경에 이 버전을 사용해선 안 된다.</p>
</dd>
</dl>
</div>
<div class="section" id="id10">
<h2>저장소 구조<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<p>소스 저장소는 다음 구조로 돼 있다.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">master</span></code> 브랜치</dt><dd><p>통합, 테스트, 개발이 이뤄지는 브랜치다. 다음 릴리스에 포함될 계획인 모든 변경 사항이 여기 병합되고 테스트가 이뤄진다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release-x.y</span></code> 브랜치</dt><dd><p>마스터 브랜치에서 새 릴리스 준비가 (거의) 되면 새 릴리스 브랜치를 딴다. 그 “릴리스 후보”는 피처를 고정하되 버그 수정과 막바지 변경 사항은 받을 수 있으며, 출시 준비가 됐다 싶으면 공식적으로 릴리스 한다. 그때부터는 “지원 브랜치”라고 부르게 되며, 계속 버그 수정을 받기는 하되 중요한 것으로 한정한다. 그 브랜치에 푸시를 할 때마다 리비전 번호가 올라가므로 중요한 변경 사항을 계속 따라갈 수 있다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bugfix_name-x.y</span></code> 브랜치</dt><dd><p>일시적인 브랜치로 기존 릴리스에 대한 사소하지 않은 버그 수정을 개발하고 공유하는 데 쓴다. 대응하는 릴리스 브랜치로 병합된 후 곧 삭제된다.</p>
</dd>
<dt>피처 브랜치</dt><dd><p>다른 브랜치는 모두 피처 브랜치다. 마스터 브랜치를 기반으로 하며, 활동이 계속 있고 <code class="docutils literal notranslate"><span class="pre">master</span></code>로 병합되지 않은 동안만 브랜치가 살아 있다.</p>
</dd>
</dl>
<p class="rubric">개발자는 어떻게 하면 되나?</p>
<p>피처를 추가하고 싶으면 <code class="docutils literal notranslate"><span class="pre">master</span></code>에서 새 브랜치를 만들면 된다. 버그를 고치고 싶으면 영향 받는 브랜치 각각에 대해 <code class="docutils literal notranslate"><span class="pre">bugfix_name-x.y</span></code> 브랜치를 따면 된다. 통합이 되도록 쉽게 이뤄지도록 각 피처 내지 버그마다 브랜치를 따로 만들어 달라. 이게 전부다. 이 페이지 아래에 git 작업 흐름 예시가 있다.</p>
<p>아, 그리고 절대로 릴리스 번호는 바꾸지 말아 달라. 우리가 통합하면서 바꾼다. 대기 중인 요청들을 우리가 어떤 순서로 당겨 갈지 알 수 없잖은가. :)</p>
<p class="rubric">배포판 관리자는 어떻게 하면 되나?</p>
<p>버그 수정과 새 릴리스는 태그를 (그리고 메일링 리스트를) 지켜보면 된다. git 저장소에서 특정 릴리스를 가져오고 싶다면 브랜치 말고 태그를 믿으면 된다. 브랜치에는 아직 릴리스 되지 않은 변경 사항이 포함돼 있을 수 있지만 태그는 버전 번호를 바꾼 바로 그 커밋을 나타낸다.</p>
</div>
<div class="section" id="id11">
<h2>패치 제출하기<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<p>변경 사항을 주 개발 브랜치로 합치는 최선의 방법은 github에서 주 저장소를 포크 하고 새 피처 브랜치를 만들어서 변경 사항을 적용한 다음 pull 요청을 보내는 것이다. 아래에 길잡이가 될 수도 있는 몇 가지 git 작업 흐름 예시들이 있다. git 호환 패치를 메일링 리스트에 제출하는 것도 괜찮다. 어느 경우든 다음 기본 규칙을 따라 주길 바란다.</p>
<ul class="simple">
<li><p><strong>문서:</strong> 패치가 하는 게 뭔지 적자. 코드에 주석을 달자. 새 기능을 추가하는 거면 다른 사람들이 알 수 있도록 문서에 내용을 추가하자.</p></li>
<li><p><strong>테스트:</strong> 코드가 예상대로 동작하며 어디에도 문제를 일으키지 않는다는 걸 증명하는 테스트를 작성하자. 버그를 수정했으면 그 버그를 유발시키는 테스트 케이스를 적어도 하나는 작성하자. 패치 제출 전에 테스트가 전부 통과하는지 확인하자.</p></li>
<li><p><strong>한 번에 패치 하나씩:</strong> 버그 수정이든 기능 추가든 한 번에 한 개씩만 하자. 패치들을 한 덩어리로 적용할 수 있도록 설계하자. 패치를 깔끔하고 작게, 한 가지에 집중하도록 작성하자.</p></li>
<li><p><strong>업스트림과 동기화:</strong> 패치 작업 중에 <code class="docutils literal notranslate"><span class="pre">upstream/master</span></code> 브랜치에 변경이 있었으면 rebase나 pull을 해서 패치가 충돌 없이 적용되도록 만들자.</p></li>
</ul>
</div>
<div class="section" id="id12">
<h2>문서 빌드 하기<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<p>문서를 빌드 하려면 Sphinx 최신 버전이 필요하다. 배포판 패키지 저장소를 이용해 <strong class="command">virtualenv</strong>를 설치한 다음 sphinx를 직접 설치해서 최신 버전을 받는 방법을 권장한다.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># 필요한 패키지 설치</span>
which virtualenv <span class="o">||</span> sudo apt-get install python-virtualenv
virtualenv --no-site-dependencies venv
./venv/pip install -U sphinx

<span class="c1"># github에서 보틀 복제하거나 내려받기</span>
git clone https://github.com/defnull/bottle.git

<span class="c1"># 빌드 환경 활성화</span>
<span class="nb">source</span> ./venv/bin/activate

<span class="c1"># HTML 문서 빌드</span>
<span class="nb">cd</span> bottle/docs
make html

<span class="c1"># 선택적: PDF 생성에 필요한 패키지 설치</span>
sudo apt-get install texlive-latex-extra <span class="se">\</span>
                     texlive-latex-recommended <span class="se">\</span>
                     texlive-fonts-recommended

<span class="c1"># 선택적: PDF로 문서 빌드</span>
make latex
<span class="nb">cd</span> ../build/docs/latex
make pdf
</pre></div>
</div>
</div>
<div class="section" id="git">
<h2>GIT 작업 흐름 예시<a class="headerlink" href="#git" title="Permalink to this headline">¶</a></h2>
<p>아래 예시에선 (무료인) <a class="reference external" href="https://github.com">github 계정</a>이 있다고 가정한다. 필수는 아니지만 일이 훨씬 쉬워진다.</p>
<p>일단은 공식 저장소의 포크(개인용 복제)를 만들어야 한다. <a class="reference external" href="https://github.com/defnull/bottle">보틀 프로젝트 페이지</a>에서 “fork” 버튼을 누르기만 하면 된다. 포크가 끝나면 새 저장소에 대한 짧은 소개가 나올 것이다.</p>
<p>방금 만든 포크는 github에 호스팅 돼 있으며 모두가 읽을 수 있지만 쓰는 건 여러분만 가능하다. 이제 실제 변경 작업을 하기 위해 그 포크를 로컬로 clone 해야 한다. (읽기 전용인) 공개 URL <em>말고</em> (읽기 및 쓰기가 가능한) 비공개 URL을 쓰도록 하자.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">clone</span> <span class="n">git</span><span class="nd">@github</span><span class="o">.</span><span class="n">com</span><span class="p">:</span><span class="n">your_github_account</span><span class="o">/</span><span class="n">bottle</span><span class="o">.</span><span class="n">git</span>
</pre></div>
</div>
<p>clone이 완료되면 “origin”이라는 리모트가 있어서 github의 포크를 가리키게 된다. 이름을 오해하지 말자. 보틀 원본 저장소가 아니라 포크를 가리키는 거다. 공식 저장소를 따라가기 위해 “upstream”이라는 또 다른 리모트를 추가하자.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="n">bottle</span>
<span class="n">git</span> <span class="n">remote</span> <span class="n">add</span> <span class="n">upstream</span> <span class="n">git</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">defnull</span><span class="o">/</span><span class="n">bottle</span><span class="o">.</span><span class="n">git</span>
<span class="n">git</span> <span class="n">fetch</span> <span class="n">upstream</span>
</pre></div>
</div>
<p>보다시피 “upstream”은 읽기 전용인 공개 clone URL이다. 거기로는 변경 사항을 바로 push 할 수 없다. 대신 그 저장소에서 pull을 하게 되는데, 좀 있다 설명한다.</p>
<p class="rubric">기능 제출</p>
<p>통합을 쉽게 하기 위해 별도의 피처 브랜치에서 새 기능을 개발한다. <code class="docutils literal notranslate"><span class="pre">master</span></code> 브랜치로 통합될 거니까 <code class="docutils literal notranslate"><span class="pre">upstream/master</span></code>를 기반으로 해야 한다. 새 피처 브랜치를 만들려면 다음을 입력하면 된다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">checkout</span> <span class="o">-</span><span class="n">b</span> <span class="n">cool_feature</span> <span class="n">upstream</span><span class="o">/</span><span class="n">master</span>
</pre></div>
</div>
<p>이제 피처를 구현하고, 테스트를 작성하고, 문서를 갱신하고, 모든 테스트가 통과하는지 확인한 다음 변경 사항을 커밋 하자.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">commit</span> <span class="o">-</span><span class="n">a</span> <span class="o">-</span><span class="n">m</span> <span class="s2">&quot;Cool Feature&quot;</span>
</pre></div>
</div>
<p>그사이 <code class="docutils literal notranslate"><span class="pre">upstream/master</span></code> 브랜치가 바뀌었으면 작성한 변경 내용과 충돌이 날 수 있다. 해결을 위해 최신 <code class="docutils literal notranslate"><span class="pre">upstream/master</span></code> 브랜치 위로 피처 브랜치를 ‘rebase’ 하자.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">fetch</span> <span class="n">upstream</span>
<span class="n">git</span> <span class="n">rebase</span> <span class="n">upstream</span>
</pre></div>
</div>
<p>이건 변경 내용을 모두 되돌린 다음 브랜치를 최신 버전으로 업데이트 하고서 패치들을 모두 재적용하는 것과 같다. 브랜치를 이미 보냈다면 (다음 단계 참고) 이 방법을 택할 수 없다. 변경 이력을 다시 만들기 때문이다. 그 경우엔 일반 pull을 할 수 있다. 충돌을 해소하고 다시 테스트를 돌린 다음 커밋 하면 된다.</p>
<p>이제 pull 요청을 보낼 준비가 거의 다 됐다. 하지만 그 전에 피처 브랜치를 github 포크로 push 해서 공개로 만들어 줘야 한다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="n">cool_feature</span>
</pre></div>
</div>
<p>커밋(들)을 push한 후에는 우리에게 새 피처에 대해 알려 줘야 한다. 일단 github를 이용해 pull 요청을 보내는 방법이 있다. 그리고 메일링 리스트에서 새 스레드를 시작하는 방법도 있는데, 이걸 권장한다. 그러면 다른 개발자들이 패치를 보고 토론할 수 있으니 여러분은 무료 피드백을 얻게 된다. :)</p>
<p>우리가 패치를 받아들이면 공식 개발 브랜치로 통합해서 다음 릴리스에 포함시키게 된다.</p>
<p class="rubric">버그 수정</p>
<p>버그 수정 작업 흐름은 피처 추가와 아주 비슷하되 몇 가지 차이가 있다.</p>
<ol class="arabic simple">
<li><p>개발 브랜치가 아니라 영향 받는 릴리스 브랜치들에서 브랜치를 딴다.</p></li>
<li><p>버그를 유발하는 테스트 케이스를 적어도 한 개 작성한다.</p></li>
<li><p>해당하는 경우 <code class="docutils literal notranslate"><span class="pre">upstream/master</span></code>까지 포함해서 영향 받는 각 브랜치에 대해 그렇게 한다. 반복 작업을 줄이는 데 <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">cherry-pick</span></code>이 도움이 될 수 있다.</p></li>
<li><p>혼동을 피하기 위해 기반이 된 릴리스를 따라 브랜치 이름을 짓는다. 예: <code class="docutils literal notranslate"><span class="pre">my_bugfix-x.y</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">my_bugfix-dev</span></code></p></li>
</ol>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Bottle</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">따라하기</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration.html">설정 (작업 중)</a></li>
<li class="toctree-l1"><a class="reference internal" href="routing.html">요청 라우팅</a></li>
<li class="toctree-l1"><a class="reference internal" href="stpl.html">SimpleTemplate 엔진</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API 참조</a></li>
<li class="toctree-l1"><a class="reference internal" href="plugins/index.html">사용 가능한 플러그인 목록</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="tutorial_app.html">따라하기: 할일 목록 응용</a></li>
<li class="toctree-l1"><a class="reference internal" href="async.html">비동기 응용 입문</a></li>
<li class="toctree-l1"><a class="reference internal" href="recipes.html">간단 해법</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">자주 묻는 질문</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="changelog.html">릴리스 노트와 변경 로그</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html#id2">기여자</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">개발자를 위해</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">참여하기</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">소스 받기</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">릴리스와 업데이트</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id10">저장소 구조</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id11">패치 제출하기</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id12">문서 빌드 하기</a></li>
<li class="toctree-l2"><a class="reference internal" href="#git">GIT 작업 흐름 예시</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="plugindev.html">플러그인 개발 안내서</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="plugins/index.html">사용 가능한 플러그인 목록</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="changelog.html" title="previous chapter">릴리스 노트와 변경 로그</a></li>
      <li>Next: <a href="plugindev.html" title="next chapter">플러그인 개발 안내서</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2009-2020, Marcel Hellkamp.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/development.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>