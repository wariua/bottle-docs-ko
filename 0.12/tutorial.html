
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>따라하기 &#8212; Bottle 0.12.18 documentation</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="설정 (초안)" href="configuration.html" />
    <link rel="prev" title="보틀: 파이썬 웹 프레임워크" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <span class="target" id="module-bottle"></span><div class="section" id="id1">
<h1>따라하기<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>여기선 보틀 웹 프레임워크의 개념과 기능을 소개하고 기초 주제와 고급 주제를 함께 다룬다. 처음부터 끝까지 읽어 나가도 되고 나중에 참고 용도로 써도 된다. 자동으로 생성되는 <a class="reference internal" href="api.html"><span class="doc">API 참조</span></a>도 흥미로울 수 있다. 더 자세한 내용을 다루지만 여기보다 설명이 적다. 흔한 질문들에 대한 해결책은 <a class="reference internal" href="recipes.html"><span class="doc">각종 해결법</span></a> 모음이나 <a class="reference internal" href="faq.html"><span class="doc">자주 묻는 질문</span></a> 페이지에서 찾을 수 있다. 혹시 도움이 필요하면 <a class="reference external" href="mailto:bottlepy&#37;&#52;&#48;googlegroups&#46;com">메일링 리스트</a>에 가입하거나 <a class="reference external" href="http://webchat.freenode.net/?channels=bottlepy">IRC 채널</a>에 가 보면 된다.</p>
<div class="section" id="installation">
<span id="id3"></span><h2>설치<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<p>보틀은 다른 외부 라이브러리에 의존하지 않는다. <a class="reference external" href="/bottle.py">bottle.py</a>를 프로젝트 디렉터리로 내려받아서 바로 코딩을 시작할 수 있다.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ wget http://bottlepy.org/bottle.py
</pre></div>
</div>
<p>이렇게 하면 신규 기능이 모두 포함된 최신 개발 스냅샷을 받게 된다. 더 안정적인 환경을 선호한다면 안정 릴리스를 쓰는 게 좋다. <a class="reference external" href="http://pypi.python.org/pypi/bottle">PyPI</a>에서 받을 수 있으며 <strong class="command">pip</strong> (권장)나 <strong class="command">easy_install</strong>, 또는 패키지 관리자를 통해 설치할 수 있다.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ sudo pip install bottle              <span class="c1"># 권장</span>
$ sudo easy_install bottle             <span class="c1"># pip 없는 경우 대안</span>
$ sudo apt-get install python-bottle   <span class="c1"># 데비안, 우분투 등에서</span>
</pre></div>
</div>
<p>어느 쪽이든 보틀 응용을 돌리려면 파이썬 2.5 또는 그 이상(3.x 포함)이 필요하다. 패키지를 시스템 전역으로 설치할 권한이 없거나 그러고 싶지 않다면 <a class="reference external" href="http://pypi.python.org/pypi/virtualenv">virtualenv</a>로 가상 환경을 만들자.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ virtualenv develop              <span class="c1"># 가상 환경 생성</span>
$ <span class="nb">source</span> develop/bin/activate     <span class="c1"># 가상 환경의 파이썬 사용</span>
<span class="o">(</span>develop<span class="o">)</span>$ pip install -U bottle  <span class="c1"># 가상 환경에 보틀 설치</span>
</pre></div>
</div>
<p>시스템에 virtualenv가 설치돼 있지 않다면:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ wget https://raw.github.com/pypa/virtualenv/master/virtualenv.py
$ python virtualenv.py develop    <span class="c1"># 가상 환경 생성</span>
$ <span class="nb">source</span> develop/bin/activate     <span class="c1"># 가상 환경의 파이썬 사용</span>
<span class="o">(</span>develop<span class="o">)</span>$ pip install -U bottle  <span class="c1"># 가상 환경에 보틀 설치</span>
</pre></div>
</div>
</div>
<div class="section" id="hello-world">
<h2>빨리 해 보기: “Hello World”<a class="headerlink" href="#hello-world" title="Permalink to this headline">¶</a></h2>
<p>보틀이 <a class="reference internal" href="#installation"><span class="std std-ref">설치돼 있거나</span></a> 프로젝트 디렉터리로 복사해 뒀다고 가정한다. 아주 기본적인 “Hello World” 예시로 시작해 보자.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bottle</span> <span class="kn">import</span> <span class="n">route</span><span class="p">,</span> <span class="n">run</span>

<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/hello&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">return</span> <span class="s2">&quot;Hello World!&quot;</span>

<span class="n">run</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s1">&#39;localhost&#39;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">8080</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>이게 전부다. 이 스크립트를 실행하고서 <a class="reference external" href="http://localhost:8080/hello">http://localhost:8080/hello</a> 주소를 열면 브라우저에 “Hello World!”가 보이게 된다. 어떻게 동작하는지 살펴보자.</p>
<p><a class="reference internal" href="api.html#bottle.route" title="bottle.route"><code class="xref py py-func docutils literal notranslate"><span class="pre">route()</span></code></a> 데코레이터는 URL 경로에 코드 조각을 결속시킨다. 이 경우에는 <code class="docutils literal notranslate"><span class="pre">/hello</span></code> 경로를 <code class="docutils literal notranslate"><span class="pre">hello()</span></code> 함수로 연결한다. 이걸 (데코레이터 이름 그대로) <cite>라우트</cite>라고 하는데 이 프레임워크에서 가장 중요한 개념이다. 원하는 만큼 마음대로 라우트를 정의할 수 있다. 브라우저가 URL을 요청하면 연계된 함수가 호출되고 그 반환 값이 브라우저로 간다. 그게 핵심이다.</p>
<p>마지막 행의 <a class="reference internal" href="api.html#bottle.run" title="bottle.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> 호출은 내장된 개발용 서버를 돌린다. <code class="docutils literal notranslate"><span class="pre">localhost</span></code> 포트 <code class="docutils literal notranslate"><span class="pre">8080</span></code>에서 돌면서 <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Control</kbd>-<kbd class="kbd docutils literal notranslate">c</kbd></kbd>를 누르기 전까지 요청을 처리한다. 이후 서버 백엔드를 교체할 수 있지만 일단은 개발용 서버만으로 충분하다. 구성 작업이 전혀 필요 없기 때문에 성가신 과정 없이 로컬 테스트를 위해 응용을 올려서 돌려볼 수 있다.</p>
<p>초기 개발 과정에는 <a class="reference internal" href="#tutorial-debugging"><span class="std std-ref">디버그 모드</span></a>가 아주 유용하지만 공개된 응용에서는 꺼 둬야 한다. 잊지 말자.</p>
<p>분명 아주 간단한 예시지만 보틀을 이용해 어떻게 응용을 만드는지 기본적인 개념을 잘 보여 준다. 그럼 또 어떤 것들이 가능한지 살펴보자.</p>
<div class="section" id="tutorial-default">
<span id="id4"></span><h3>기본 응용<a class="headerlink" href="#tutorial-default" title="Permalink to this headline">¶</a></h3>
<p>단순함을 위해 여기 있는 예시 대부분에선 모듈 층위의 <a class="reference internal" href="api.html#bottle.route" title="bottle.route"><code class="xref py py-func docutils literal notranslate"><span class="pre">route()</span></code></a> 데코레이터를 써서 라우트를 정의한다. 그러면 전역 “기본 응용”에 라우트가 추가되며 <a class="reference internal" href="api.html#bottle.route" title="bottle.route"><code class="xref py py-func docutils literal notranslate"><span class="pre">route()</span></code></a>를 처음 호출할 때 <a class="reference internal" href="api.html#bottle.Bottle" title="bottle.Bottle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bottle</span></code></a> 인스턴스가 자동으로 생성된다. 몇 가지 다른 모듈 층위 데코레이터와 함수들도 그 기본 응용과 관련돼 있다. 하지만 객체 지향적인 방식을 선호하고 키보드를 더 두드리는 게 괜찮다면 따로 응용 객체를 만들어서 전역 객체 대신 쓸 수도 있다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bottle</span> <span class="kn">import</span> <span class="n">Bottle</span><span class="p">,</span> <span class="n">run</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Bottle</span><span class="p">()</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/hello&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">return</span> <span class="s2">&quot;Hello World!&quot;</span>

<span class="n">run</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">host</span><span class="o">=</span><span class="s1">&#39;localhost&#39;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">8080</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#default-app"><span class="std std-ref">기본 응용</span></a> 절에서 객체 지향 방식을 더 설명한다. 일단은 선택지가 있다는 것만 기억해 두자.</p>
</div>
</div>
<div class="section" id="tutorial-routing">
<span id="id5"></span><h2>요청 라우팅<a class="headerlink" href="#tutorial-routing" title="Permalink to this headline">¶</a></h2>
<p>앞 장에서 라우트가 한 개만 있는 아주 간단한 웹 응용을 만들어 봤다. 다음은 “Hello World” 예시의 라우팅 부분이다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/hello&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">return</span> <span class="s2">&quot;Hello World!&quot;</span>
</pre></div>
</div>
<p><a class="reference internal" href="api.html#bottle.route" title="bottle.route"><code class="xref py py-func docutils literal notranslate"><span class="pre">route()</span></code></a> 데코레이터가 URL 경로를 콜백 함수로 연결하고 <a class="reference internal" href="#tutorial-default"><span class="std std-ref">기본 응용</span></a>에 새 라우트를 추가해 준다. 하지만 라우트가 하나 뿐인 응용은 별로 재미가 없으니 좀 더 추가해 보자.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/hello/&lt;name&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Stranger&#39;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">template</span><span class="p">(</span><span class="s1">&#39;Hello {{name}}, how are you?&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>이 예에서 두 가지를 볼 수 있다. 콜백 하나에 라우트를 여러 개 결속시킬 수 있고, URL에 와일드카드를 추가해서 키워드 인자를 통해 접근할 수 있다.</p>
<div class="section" id="tutorial-dynamic-routes">
<span id="id6"></span><h3>동적 라우트<a class="headerlink" href="#tutorial-dynamic-routes" title="Permalink to this headline">¶</a></h3>
<p>와일드카드를 포함한 라우트를 <cite>동적 라우트</cite>라고 하며 (반대는 <cite>정적 라우트</cite>), 동시에 여러 URL에 걸린다. 간단한 와일드카드는 이름을 꺾쇠괄호로 감싼 것이며 다음 슬래시(<code class="docutils literal notranslate"><span class="pre">/</span></code>) 전까지 하나 이상의 문자를 받는다. 예를 들어 라우트 <code class="docutils literal notranslate"><span class="pre">/hello/&lt;name&gt;</span></code>은 <code class="docutils literal notranslate"><span class="pre">/hello/alice</span></code>와 <code class="docutils literal notranslate"><span class="pre">/hello/bob</span></code> 요청은 받지만 <code class="docutils literal notranslate"><span class="pre">/hello</span></code>나 <code class="docutils literal notranslate"><span class="pre">/hello/</span></code>, <code class="docutils literal notranslate"><span class="pre">/hello/mr/smith</span></code> 요청은 받지 않는다.</p>
<p>URL에서 각 와일드카드가 걸린 부분이 요청 콜백에 키워드 인자로 전달된다. 이를 바로 이용하면 RESTful이고 보기 좋으면서 유의미한 URL을 간단히 구현할 수 있다. 다음은 몇 가지 다른 예시들와 걸리는 URL이다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/wiki/&lt;pagename&gt;&#39;</span><span class="p">)</span>            <span class="c1"># /wiki/Learning_Python 걸림</span>
<span class="k">def</span> <span class="nf">show_wiki_page</span><span class="p">(</span><span class="n">pagename</span><span class="p">):</span>
    <span class="o">...</span>

<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/&lt;action&gt;/&lt;user&gt;&#39;</span><span class="p">)</span>            <span class="c1"># /follow/defnull 걸림</span>
<span class="k">def</span> <span class="nf">user_api</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="n">user</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.10.</span></p>
</div>
<p>필터를 사용해 와일드카드를 더 구체적으로 정의하고 URL의 걸린 부분이 콜백으로 전달되기 전에 변환을 할 수 있다. 필터 와일드카드는 <code class="docutils literal notranslate"><span class="pre">&lt;name:filter&gt;</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">&lt;name:filter:config&gt;</span></code> 형식으로 선언한다. 선택적인 config 부분의 문법은 사용 필터에 따라 다르다.</p>
<p>다음 필터들이 기본으로 구현돼 있으며 더 추가할 수도 있다.</p>
<ul class="simple">
<li><p><strong>:int</strong> (부호 있는) 숫자에만 걸리고 값을 정수로 변환한다.</p></li>
<li><p><strong>:float</strong> :int와 비슷하되 부동소수점수다.</p></li>
<li><p><strong>:path</strong> 슬래시 문자를 포함한 모든 문자들에 비탐욕 방식으로 걸리며 하나 이상의 경로 분절이 걸리게 하는 데 쓸 수 있다.</p></li>
<li><p><strong>:re</strong> config 필드에 원하는 정규 표현식을 지정할 수 있다. 걸린 값이 변환되지는 않는다.</p></li>
</ul>
<p>현실적인 예시를 몇 가지 살펴보자.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/object/&lt;id:int&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="nb">id</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/show/&lt;name:re:[a-z]+&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">name</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()</span>

<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/static/&lt;path:path&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">static_file</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>새로운 필터를 추가할 수도 있다. 자세한 건 <a class="reference internal" href="routing.html"><span class="doc">요청 라우팅</span></a> 참고.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.10.</span></p>
</div>
<p>흔한 사용 방식들을 단순화하기 위해 <strong>보틀 0.10</strong>에서 새로운 규칙 문법이 도입됐다. 하지만 이전 문법도 여전히 동작하며 많은 코드 예시에서 이전 문법을 쓰는 걸 볼 수 있다. 예시를 보면 차이를 잘 알 수 있다.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 49%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>이전 문법</p></th>
<th class="head"><p>새 문법</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">:name</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;name&gt;</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">:name#regexp#</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;name:re:regexp&gt;</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">:#regexp#</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;:re:regexp&gt;</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">:##</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;:re&gt;</span></code></p></td>
</tr>
</tbody>
</table>
<p>향후 프로젝트에선 되도록 이전 문법을 피하자. 현재는 폐기 예정이 아니지만 언젠간 폐기될 것이다.</p>
</div>
<div class="section" id="http">
<h3>HTTP 요청 메소드<a class="headerlink" href="#http" title="Permalink to this headline">¶</a></h3>
<p>HTTP 프로토콜에서는 다양한 작업을 위한 몇 가지 <a class="reference external" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">요청 메소드</a>(“동사(verb)”라고도 함)를 규정하고 있다. 따로 메소드를 지정하지 않으면 모든 라우트에 GET이 기본이다. 그 라우트는 GET 요청에만 걸리게 된다. POST나 PUT, DELETE 같은 다른 메소드를 처리하고 싶으면 <a class="reference internal" href="api.html#bottle.route" title="bottle.route"><code class="xref py py-func docutils literal notranslate"><span class="pre">route()</span></code></a> 데코레이터에 키워드 인자 <code class="docutils literal notranslate"><span class="pre">method</span></code>를 추가하거나 <a class="reference internal" href="api.html#bottle.get" title="bottle.get"><code class="xref py py-func docutils literal notranslate"><span class="pre">get()</span></code></a>, <a class="reference internal" href="api.html#bottle.post" title="bottle.post"><code class="xref py py-func docutils literal notranslate"><span class="pre">post()</span></code></a>, <a class="reference internal" href="api.html#bottle.put" title="bottle.put"><code class="xref py py-func docutils literal notranslate"><span class="pre">put()</span></code></a>, <a class="reference internal" href="api.html#bottle.delete" title="bottle.delete"><code class="xref py py-func docutils literal notranslate"><span class="pre">delete()</span></code></a> 데코레이터를 대신 쓰면 된다.</p>
<p>HTML 양식 제출에는 POST 메소드를 흔히 쓴다. 다음 예는 POST를 이용한 로그인 양식 처리를 보여 준다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bottle</span> <span class="kn">import</span> <span class="n">get</span><span class="p">,</span> <span class="n">post</span><span class="p">,</span> <span class="n">request</span> <span class="c1"># 또는 route</span>

<span class="nd">@get</span><span class="p">(</span><span class="s1">&#39;/login&#39;</span><span class="p">)</span> <span class="c1"># 또는 @route(&#39;/login&#39;)</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">        &lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt;</span>
<span class="s1">            Username: &lt;input name=&quot;username&quot; type=&quot;text&quot; /&gt;</span>
<span class="s1">            Password: &lt;input name=&quot;password&quot; type=&quot;password&quot; /&gt;</span>
<span class="s1">            &lt;input value=&quot;Login&quot; type=&quot;submit&quot; /&gt;</span>
<span class="s1">        &lt;/form&gt;</span>
<span class="s1">    &#39;&#39;&#39;</span>

<span class="nd">@post</span><span class="p">(</span><span class="s1">&#39;/login&#39;</span><span class="p">)</span> <span class="c1"># 또는 @route(&#39;/login&#39;, method=&#39;POST&#39;)</span>
<span class="k">def</span> <span class="nf">do_login</span><span class="p">():</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">forms</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;username&#39;</span><span class="p">)</span>
    <span class="n">password</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">forms</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;password&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">check_login</span><span class="p">(</span><span class="n">username</span><span class="p">,</span> <span class="n">password</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;p&gt;Your login information was correct.&lt;/p&gt;&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;p&gt;Login failed.&lt;/p&gt;&quot;</span>
</pre></div>
</div>
<p>이 예에선 <code class="docutils literal notranslate"><span class="pre">/login</span></code> URL이 두 가지 다른 콜백에 연결돼 있다. GET 요청 콜백은 사용자에게 HTML 양식을 표시한다. POST 요청 콜백은 양식 제출 시 호출되어 사용자가 양식에 입력한 로그인 정보를 검사한다. <a class="reference internal" href="#tutorial-request"><span class="std std-ref">요청 데이터</span></a> 절에서 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.forms</span></code> 사용법을 더 설명한다.</p>
<p class="rubric">특수 메소드: HEAD와 ANY</p>
<p>HEAD 메소드는 GET 요청 응답과 동일하되 바디는 없는 응답을 요청하는 데 쓴다. 문서 전체를 내려받을 필요 없이 자원에 대한 메타 정보를 얻는 데 유용하다. 보틀에선 그 요청을 받았는데 맞는 라우트가 없으면 자동으로 대응하는 GET 라우트로 간 다음 응답 바디가 있으면 잘라내는 방식으로 처리한다. 즉 HEAD 라우트를 따로 지정해 줄 필요가 없다.</p>
<p>그리고 낮은 우선순위로 동작하는 비표준 ANY 메소드를 쓸 수도 있다. ANY에 대한 라우트는 HTTP 메소드와 상관없이 요청을 잡아채는데, 다른 구체적 라우트가 정의돼 있지 않은 경우에만 그렇게 한다. 요청을 더 구체적인 하위 응용으로 돌리는 <em>프록시 라우트</em>에 유용하다.</p>
<p>요약하면 원래 요청 메소드에 맞는 라우트가 없는 경우에서, HEAD 요청이 GET 라우트로 가고 모든 요청이 ANY 라우트로 간다. 아주 간단하다.</p>
</div>
<div class="section" id="id8">
<h3>정적 파일 라우팅<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>이미지나 CSS 파일 같은 정적 파일이 자동으로 처리되지 않는다. 라우트와 콜백을 추가해서 어떤 파일을 제공하고 어디서 얻을 수 있는지 지정해 줘야 한다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bottle</span> <span class="kn">import</span> <span class="n">static_file</span>
<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/static/&lt;filename&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">server_static</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">static_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="s1">&#39;/path/to/your/static/files&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">static_file()</span></code> 함수는 안전하고 편리하게 파일들을 제공할 수 있는 헬퍼다. (<a class="reference internal" href="#tutorial-static-files"><span class="std std-ref">정적 파일</span></a> 참고.) <code class="docutils literal notranslate"><span class="pre">&lt;filename&gt;</span></code> 와일드카드가 슬래시를 포함한 경로에는 걸리지 않기 때문에 이 예는 <code class="docutils literal notranslate"><span class="pre">/path/to/your/static/files</span></code> 디렉터리 바로 안에 있는 파일들만 제공할 수 있다. 하위 디렉터리 안의 파일도 제공하려면 와일드카드에 <cite>path</cite> 필터를 쓰면 된다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/static/&lt;filepath:path&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">server_static</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">static_file</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="s1">&#39;/path/to/your/static/files&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">root='./static/files'</span></code>처럼 상대적으로 루트 경로를 지정할 때는 조심해야 한다. 작업 디렉터리(<code class="docutils literal notranslate"><span class="pre">./</span></code>)와 프로젝트 디렉터리가 항상 같지는 않다.</p>
</div>
<div class="section" id="tutorial-errorhandling">
<span id="id9"></span><h3>오류 페이지<a class="headerlink" href="#tutorial-errorhandling" title="Permalink to this headline">¶</a></h3>
<p>뭔가 잘못되면 정보는 있지만 꽤 밋밋한 오류 페이지를 보틀에서 표시한다. <a class="reference internal" href="api.html#bottle.error" title="bottle.error"><code class="xref py py-func docutils literal notranslate"><span class="pre">error()</span></code></a> 데코레이터로 특정 HTTP 상태 코드에 대한 기본 페이지를 바꿀 수 있다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bottle</span> <span class="kn">import</span> <span class="n">error</span>
<span class="nd">@error</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">error404</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;Nothing here, sorry&#39;</span>
</pre></div>
</div>
<p>그러면 <cite>404 File Not Found</cite> 오류 발생 시 따로 만든 오류 페이지가 사용자에게 표시된다. 오류 핸들러로 전달되는 유일한 매개변수는 <a class="reference internal" href="api.html#bottle.HTTPError" title="bottle.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a> 인스턴스다. 그 외에는 오류 핸들러와 일반 요청 콜백이 꽤 비슷하다. <a class="reference internal" href="api.html#id0" title="bottle.request"><code class="xref py py-data docutils literal notranslate"><span class="pre">request</span></code></a>에서 읽을 수 있고 <a class="reference internal" href="api.html#bottle.response" title="bottle.response"><code class="xref py py-data docutils literal notranslate"><span class="pre">response</span></code></a>로 쓸 수 있으며 <a class="reference internal" href="api.html#bottle.HTTPError" title="bottle.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a> 인스턴스를 빼고 지원하는 어떤 데이터 타입이든 반환할 수 있다.</p>
<p>응용에서 <a class="reference internal" href="api.html#bottle.HTTPError" title="bottle.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a> 예외를 반환하거나 던진 (<code class="xref py py-func docutils literal notranslate"><span class="pre">abort()</span></code>) 경우에만 오류 핸들러가 쓰인다. <code class="xref py py-attr docutils literal notranslate"><span class="pre">Response.status</span></code>를 바꾸거나 <a class="reference internal" href="api.html#bottle.HTTPResponse" title="bottle.HTTPResponse"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPResponse</span></code></a>를 반환하는 걸로는 오류 핸들러가 실행되지 않는다.</p>
</div>
</div>
<div class="section" id="tutorial-output">
<span id="id10"></span><h2>내용물 생성하기<a class="headerlink" href="#tutorial-output" title="Permalink to this headline">¶</a></h2>
<p>순수한 WSGI에서는 응용에서 반환할 수 있는 타입 종류가 아주 제한돼 있다. 바이트열을 내놓는 이터러블을 응용에서 반환해야 한다. (문자열도 이터러블이니까) 문자열을 반환할 수도 있지만, 그러면 대부분 서버는 내용물을 한 글자씩 전송하게 된다. 유니코드열은 아예 허용되지 않는다. 이래선 실용성이 너무 떨어진다.</p>
<p>보틀은 훨씬 더 유연하게 다양한 타입들을 지원한다. 게다가 가능한 경우 <code class="docutils literal notranslate"><span class="pre">Content-Length</span></code> 헤더를 추가해 주기도 하며, 유니코드를 자동으로 인코딩하기에 직접 해 줄 필요가 없다. 다음은 응용 콜백에서 반환할 수 있는 데이터 타입 목록과 프레임워크에서 처리하는 방식에 대한 간단한 설명이다.</p>
<dl class="simple">
<dt>딕셔너리</dt><dd><p>앞서 언급한 것처럼 파이썬 딕셔너리(와 그 서브클래스)는 자동으로 JSON 문자열로 변환돼서 <code class="docutils literal notranslate"><span class="pre">Content-Type</span></code> 헤더를 <code class="docutils literal notranslate"><span class="pre">application/json</span></code>으로 하고 브라우저로 반환된다. 그래서 JSON 기반 API를 쉽게 구현할 수 있다. JSON 외 다른 데이터 형식들도 지원한다. 자세한 내용은 <span class="xref std std-ref">tutorial-output-filter</span> 참고.</p>
</dd>
<dt>빈 문자열, <code class="docutils literal notranslate"><span class="pre">False</span></code>, <code class="docutils literal notranslate"><span class="pre">None</span></code>, 기타 참 아닌 값:</dt><dd><p>빈 출력을 만들고 <code class="docutils literal notranslate"><span class="pre">Content-Length</span></code> 헤더를 0으로 설정한다.</p>
</dd>
<dt>유니코드열</dt><dd><p>유니코드열(또는 유니코드열을 내놓는 이터러블)은 자동으로 <code class="docutils literal notranslate"><span class="pre">Content-Type</span></code> 헤더에 지정된 코덱(기본은 utf8)으로 인코딩돼서 일반 바이트열처럼 (아래 참고) 처리된다.</p>
</dd>
<dt>바이트열</dt><dd><p>보틀에선 열을 (글자 하나씩 돌지 않고) 통째로 반환하며 열 길이를 가지고 <code class="docutils literal notranslate"><span class="pre">Content-Length</span></code> 헤더를 추가해 준다. 바이트열 리스트는 먼저 하나로 합친다. 바이트열을 내놓는 다른 이터러블은 합치지 않는데, 너무 커져서 메모리에 안 들어갈 수도 있기 때문이다. 그 경우 <code class="docutils literal notranslate"><span class="pre">Content-Length</span></code> 헤더를 설정하지 않는다.</p>
</dd>
<dt><a class="reference internal" href="api.html#bottle.HTTPError" title="bottle.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a> 또는 <a class="reference internal" href="api.html#bottle.HTTPResponse" title="bottle.HTTPResponse"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPResponse</span></code></a> 인스턴스</dt><dd><p>이걸 반환하는 건 예외로 던지는 것과 효과가 같다. <a class="reference internal" href="api.html#bottle.HTTPError" title="bottle.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a>인 경우 오류 핸들러를 사용한다. 자세한 건 <a class="reference internal" href="#tutorial-errorhandling"><span class="std std-ref">오류 페이지</span></a> 참고.</p>
</dd>
<dt>파일 객체</dt><dd><p><code class="docutils literal notranslate"><span class="pre">.read()</span></code> 메소드가 있는 모든 걸 파일 내지 파일스러운 객체로 보고 WSGI 서버 프레임워크에 정의돼 있는 콜러블 <code class="docutils literal notranslate"><span class="pre">wsgi.file_wrapper</span></code>로 전달한다. 일부 WSGI 서버 구현에선 최적화된 시스템 호출(sendfile)을 이용해 더 효율적으로 파일을 전송할 수 있다. 다른 경우엔 그냥 메모리에 들어가는 크기의 덩어리만큼씩 돈다. <code class="docutils literal notranslate"><span class="pre">Content-Length</span></code>나 <code class="docutils literal notranslate"><span class="pre">Content-Type</span></code> 같은 선택적인 헤더들이 자동으로 설정되지 <em>않는다</em>. 되도록 <code class="xref py py-func docutils literal notranslate"><span class="pre">send_static()</span></code>을 쓰는 게 좋다. 자세한 건 <a class="reference internal" href="#tutorial-static-files"><span class="std std-ref">정적 파일</span></a> 참고.</p>
</dd>
<dt>이터러블과 제너레이터</dt><dd><p>콜백 내에서 <code class="docutils literal notranslate"><span class="pre">yield</span></code>를 쓰거나 이터러블을 반환할 수도 있다. 단 그 이터러블은 바이트열이나 유니코드열, <a class="reference internal" href="api.html#bottle.HTTPError" title="bottle.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a>나 <a class="reference internal" href="api.html#bottle.HTTPResponse" title="bottle.HTTPResponse"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPResponse</span></code></a> 인스턴스를 내놓아야 한다. 미안하지만 중첩 이터러블은 안 된다. 이터러블이 비어 있지 않은 값을 내놓는 즉시 HTTP 상태 코드와 헤더들을 브라우저로 보낸다는 점에 유의하자. 이후에 바꿔도 효과가 없다.</p>
</dd>
</dl>
<p>이 목록의 순서도 중요하다. 예를 들어 <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>의 서브클래스를 반환하는데 그 객체에 <code class="docutils literal notranslate"><span class="pre">read()</span></code> 메소드도 있을 수 있다. 문자열을 먼저 처리하기 때문에 파일이 아니라 문자열로 처리한다.</p>
<p class="rubric">기본 인코딩 바꾸기</p>
<p>보틀에선 <code class="docutils literal notranslate"><span class="pre">Content-Type</span></code> 헤더의 <cite>charset</cite> 매개변수를 이용해 유니코드열을 어떻게 인코딩 할지 정한다. 그 헤더의 기본값은 <code class="docutils literal notranslate"><span class="pre">text/html;</span> <span class="pre">charset=UTF8</span></code>이고 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Response.content_type</span></code> 속성으로 바꿀 수 있다. 아니면 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Response.charset</span></code> 속성을 바로 설정할 수도 있다. (<a class="reference internal" href="api.html#bottle.Response" title="bottle.Response"><code class="xref py py-class docutils literal notranslate"><span class="pre">Response</span></code></a> 객체는 <a class="reference internal" href="#tutorial-response"><span class="std std-ref">Response 객체</span></a> 절에서 설명한다.)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bottle</span> <span class="kn">import</span> <span class="n">response</span>
<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/iso&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_iso</span><span class="p">():</span>
    <span class="n">response</span><span class="o">.</span><span class="n">charset</span> <span class="o">=</span> <span class="s1">&#39;ISO-8859-15&#39;</span>
    <span class="k">return</span> <span class="sa">u</span><span class="s1">&#39;This will be sent with ISO-8859-15 encoding.&#39;</span>

<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/latin9&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_latin</span><span class="p">():</span>
    <span class="n">response</span><span class="o">.</span><span class="n">content_type</span> <span class="o">=</span> <span class="s1">&#39;text/html; charset=latin9&#39;</span>
    <span class="k">return</span> <span class="sa">u</span><span class="s1">&#39;ISO-8859-15 is also known as latin9.&#39;</span>
</pre></div>
</div>
<p>일부 드문 경우에 파이썬 인코딩 이름이 HTTP 명세에서 지원하는 이름과 다르다. 그때는 먼저 (클라이언트에게 그대로 전송되는) <code class="xref py py-attr docutils literal notranslate"><span class="pre">Response.content_type</span></code> 헤더를 설정한 다음 (유니코드 인코딩에 쓰는) <code class="xref py py-attr docutils literal notranslate"><span class="pre">Response.charset</span></code> 속성을 설정해야 한다.</p>
<div class="section" id="tutorial-static-files">
<span id="id11"></span><h3>정적 파일<a class="headerlink" href="#tutorial-static-files" title="Permalink to this headline">¶</a></h3>
<p>파일 객체를 바로 반환할 수도 있지만 정적 파일을 제공하는 권장하는 방식은 <code class="xref py py-func docutils literal notranslate"><span class="pre">static_file()</span></code>이다. 자동으로 마임 타입을 추측하고, <code class="docutils literal notranslate"><span class="pre">Last-Modified</span></code> 헤더를 추가해 주며, 보안을 위해 경로를 <code class="docutils literal notranslate"><span class="pre">root</span></code> 디렉터리로 제한해 주고, 적절한 오류 응답(권한 오류에는 403, 파일이 없으면 404)을 만들어 준다. <code class="docutils literal notranslate"><span class="pre">If-Modified-Since</span></code> 헤더도 지원하며 <code class="docutils literal notranslate"><span class="pre">304</span> <span class="pre">Not</span> <span class="pre">Modified</span></code> 응답까지 생성할 수 있다. 따로 마임 타입을 줘서 추측 동작을 끌 수도 있다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bottle</span> <span class="kn">import</span> <span class="n">static_file</span>
<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/images/&lt;filename:re:.*\.png&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">send_image</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">static_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="s1">&#39;/path/to/image/files&#39;</span><span class="p">,</span> <span class="n">mimetype</span><span class="o">=</span><span class="s1">&#39;image/png&#39;</span><span class="p">)</span>

<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/static/&lt;filename:path&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">send_static</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">static_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="s1">&#39;/path/to/static/files&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>정말 필요한 경우에는 <code class="xref py py-func docutils literal notranslate"><span class="pre">static_file()</span></code>의 반환 값을 예외로 던질 수도 있다.</p>
<p class="rubric">내려받기 대화창</p>
<p>대부분의 브라우저에서는 마임 타입을 알고 있고 어떤 응용에 할당돼 있으면 (예: PDF 파일) 내려받은 파일을 열려고 한다. 그걸 원하는 게 아니라면 내려받기 대화창을 꼭 표시하게 하고 사용자에게 파일 이름 제안까지 할 수 있다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/download/&lt;filename:path&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">download</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">static_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="s1">&#39;/path/to/static/files&#39;</span><span class="p">,</span> <span class="n">download</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">download</span></code> 매개변수가 그냥 <code class="docutils literal notranslate"><span class="pre">True</span></code>면 원본 파일 이름을 쓴다.</p>
</div>
<div class="section" id="tutorial-error">
<span id="id12"></span><h3>HTTP 오류와 재지향<a class="headerlink" href="#tutorial-error" title="Permalink to this headline">¶</a></h3>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">abort()</span></code> 함수를 써서 간단하게 HTTP 오류 페이지를 생성할 수 있다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bottle</span> <span class="kn">import</span> <span class="n">route</span><span class="p">,</span> <span class="n">abort</span>
<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/restricted&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">restricted</span><span class="p">():</span>
    <span class="n">abort</span><span class="p">(</span><span class="mi">401</span><span class="p">,</span> <span class="s2">&quot;Sorry, access denied.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>클라이언트를 다른 URL로 보내기 위해 <code class="docutils literal notranslate"><span class="pre">Location</span></code> 헤더를 새 URL로 설정하고 <code class="docutils literal notranslate"><span class="pre">303</span> <span class="pre">See</span> <span class="pre">Other</span></code> 응답을 보낼 수 있다. <code class="xref py py-func docutils literal notranslate"><span class="pre">redirect()</span></code>가 그걸 대신 해 준다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bottle</span> <span class="kn">import</span> <span class="n">redirect</span>
<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/wrong/url&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">wrong</span><span class="p">():</span>
    <span class="n">redirect</span><span class="p">(</span><span class="s2">&quot;/right/url&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>두 번째 매개변수로 다른 HTTP 상태 코드를 줄 수도 있다.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>두 함수 모두 <a class="reference internal" href="api.html#bottle.HTTPError" title="bottle.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a> 예외를 던져서 콜백 코드 실행을 중단시킨다.</p>
</div>
<p class="rubric">다른 예외</p>
<p><a class="reference internal" href="api.html#bottle.HTTPResponse" title="bottle.HTTPResponse"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPResponse</span></code></a>와 <a class="reference internal" href="api.html#bottle.HTTPError" title="bottle.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a>를 제외한 다른 예외들은 <code class="docutils literal notranslate"><span class="pre">500</span> <span class="pre">Internal</span> <span class="pre">Server</span> <span class="pre">Error</span></code> 응답을 만들게 되고 그래서 WSGI 서버가 죽지 않는다. 미들웨어의 이런 예외 처리 동작을 끄려면 <code class="docutils literal notranslate"><span class="pre">bottle.app().catchall</span></code>을 <code class="docutils literal notranslate"><span class="pre">False</span></code>로 설정하면 된다.</p>
</div>
<div class="section" id="response">
<span id="tutorial-response"></span><h3><a class="reference internal" href="api.html#bottle.Response" title="bottle.Response"><code class="xref py py-class docutils literal notranslate"><span class="pre">Response</span></code></a> 객체<a class="headerlink" href="#response" title="Permalink to this headline">¶</a></h3>
<p>HTTP 상태 코드, 응답 헤더, 쿠키 등의 응답 메타데이터가 <a class="reference internal" href="api.html#bottle.response" title="bottle.response"><code class="xref py py-data docutils literal notranslate"><span class="pre">response</span></code></a>라는 객체에 저장됐다가 브라우저로 전송된다. 그 메타데이터를 직접 조작할 수도 있고 미리 정의된 헬퍼 메소드를 이용할 수도 있다. 전체 API와 기능들이 API 절에 설명돼 있지만 (<a class="reference internal" href="api.html#bottle.Response" title="bottle.Response"><code class="xref py py-class docutils literal notranslate"><span class="pre">Response</span></code></a> 참고) 여기서도 주요 사용법과 기능들을 살펴본다.</p>
<p class="rubric">상태 코드</p>
<p><a class="reference external" href="http_code">HTTP 상태 코드</a>는 브라우저의 동작을 제어하며 기본은 <code class="docutils literal notranslate"><span class="pre">200</span> <span class="pre">OK</span></code>다. 대부분 상황에선 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Response.status</span></code> 속성을 직접 설정할 필요가 없고 <code class="xref py py-func docutils literal notranslate"><span class="pre">abort()</span></code> 헬퍼를 쓰거나 <a class="reference internal" href="api.html#bottle.HTTPResponse" title="bottle.HTTPResponse"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPResponse</span></code></a> 인스턴스를 반환하면서 적당한 상태 코드를 주면 된다. 어떤 정수든 허용되지만 <a class="reference external" href="http_code">HTTP 명세</a>에서 규정한 것 외의 코드는 브라우저를 혼란시킬 뿐이며 표준을 깨는 것이다.</p>
<p class="rubric">응답 헤더</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Response.set_header()</span></code>를 통해 <code class="docutils literal notranslate"><span class="pre">Cache-Control</span></code>이나 <code class="docutils literal notranslate"><span class="pre">Location</span></code> 같은 응답 헤더들을 지정한다. 이 메소드는 매개변수를 두 개 받는데, 각각 헤더 이름과 값이다. 이름에서 대소문자를 구별하지 않는다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/wiki/&lt;page&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">wiki</span><span class="p">(</span><span class="n">page</span><span class="p">):</span>
    <span class="n">response</span><span class="o">.</span><span class="n">set_header</span><span class="p">(</span><span class="s1">&#39;Content-Language&#39;</span><span class="p">,</span> <span class="s1">&#39;en&#39;</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>대부분 헤더는 유일하다. 즉 이름별로 한 헤더만 클라이언트에게 보낸다. 하지만 일부 특수 헤더는 응답에 여러 번 등장할 수 있다. 그런 헤더를 추가하려면 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Response.set_header()</span></code> 대신 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Response.add_header()</span></code>를 쓰면 된다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">response</span><span class="o">.</span><span class="n">set_header</span><span class="p">(</span><span class="s1">&#39;Set-Cookie&#39;</span><span class="p">,</span> <span class="s1">&#39;name=value&#39;</span><span class="p">)</span>
<span class="n">response</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;Set-Cookie&#39;</span><span class="p">,</span> <span class="s1">&#39;name2=value2&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>이는 예시일 뿐이다. 쿠키 처리를 하고 싶다면 <a class="reference internal" href="#tutorial-cookies"><span class="std std-ref">다음 절</span></a>을 읽어 보자.</p>
</div>
<div class="section" id="tutorial-cookies">
<span id="id15"></span><h3>쿠키<a class="headerlink" href="#tutorial-cookies" title="Permalink to this headline">¶</a></h3>
<p>쿠키란 사용자의 브라우저 프로파일에 저장되는 이름 있는 텍스트 조각이다. <code class="xref py py-meth docutils literal notranslate"><span class="pre">Request.get_cookie()</span></code>를 통해 앞서 정의된 쿠키에 접근할 수 있고 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Response.set_cookie()</span></code>로 새 쿠키를 설정할 수 있다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/hello&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello_again</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">get_cookie</span><span class="p">(</span><span class="s2">&quot;visited&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Welcome back! Nice to see you again&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">response</span><span class="o">.</span><span class="n">set_cookie</span><span class="p">(</span><span class="s2">&quot;visited&quot;</span><span class="p">,</span> <span class="s2">&quot;yes&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;Hello there! Nice to meet you&quot;</span>
</pre></div>
</div>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Response.set_cookie()</span></code> 메소드는 쿠키 수명과 동작을 제어하는 여러 추가 키워드 인자들을 받는다. 자주 쓰는 설정은 다음과 같다.</p>
<ul class="simple">
<li><p><strong>max_age:</strong>    초 단위 최대 수명. (기본값: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
<li><p><strong>expires:</strong>    datetime 객체 또는 유닉스 타임스탬프. (기본값: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
<li><p><strong>domain:</strong>     쿠키를 읽는 게 허용되는 도메인. (기본값: 현재 도메인)</p></li>
<li><p><strong>path:</strong>       쿠키를 지정된 경로로 제한. (기본값: <code class="docutils literal notranslate"><span class="pre">/</span></code>)</p></li>
<li><p><strong>secure:</strong>     쿠키를 HTTPS 연결로 제한. (기본값: 꺼짐)</p></li>
<li><p><strong>httponly:</strong>   클라이언트 측 자바스크립트에서 이 쿠키를 읽지 못하게 하기. (기본값: 꺼짐. 파이썬 2.6 이상 필요.)</p></li>
</ul>
<p><cite>expires</cite>와 <cite>max_age</cite> 어느 쪽도 설정하지 않으면 브라우저 세션이 끝날 때, 즉 브라우저 창이 닫힐 때 쿠키가 만료된다. 쿠키 사용 시 고려해야 할 사항들이 몇 가지 있다.</p>
<ul class="simple">
<li><p>대부분 브라우저에서 쿠키가 4 KB 텍스트로 제한된다.</p></li>
<li><p>일부 사용자들은 쿠키를 전혀 허용하지 않도록 브라우저를 설정한다. 검색 엔진에서도 대부분 쿠키를 무시한다. 쿠키 없이도 응용이 동작하게 해야 한다.</p></li>
<li><p>쿠키는 클라이언트에 저장되며 어떤 식으로도 암호화되지 않는다. 즉 쿠키에 저장한 모든 걸 사용자가 읽을 수 있다. 게다가 공격자가 서버의 <a class="reference external" href="http://en.wikipedia.org/wiki/HTTP_cookie#Cookie_theft_and_session_hijacking">XSS</a> 취약성을 통해 사용자 쿠키를 훔치는 게 가능할 수도 있고 어떤 바이러스는 브라우저 쿠키를 읽어 간다고 한다. 즉 절대 비밀 정보를 쿠키에 저장해선 안 된다.</p></li>
<li><p>악의적인 공격자가 손쉽게 쿠키를 위조할 수 있다. 쿠키를 신뢰해선 안 된다.</p></li>
</ul>
<p class="rubric" id="tutorial-signed-cookies">쿠키 서명</p>
<p>앞서 언급한 것처럼 악의적 클라이언트가 손쉽게 쿠키를 위조할 수 있다. 이런 조작을 막기 위해 쿠키에 암호학적 서명을 할 수 있다. 쿠키를 읽거나 설정할 때마다 <cite>secret</cite> 키워드 인자를 통해 서명 키를 제공하고 그 키를 비밀로 유지하기만 하면 된다. 그렇게 하면 쿠키에 서명이 돼 있지 않거나 서명이 일치하지 않는 경우 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Request.get_cookie()</span></code>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환하게 된다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/login&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">do_login</span><span class="p">():</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">forms</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;username&#39;</span><span class="p">)</span>
    <span class="n">password</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">forms</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;password&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">check_login</span><span class="p">(</span><span class="n">username</span><span class="p">,</span> <span class="n">password</span><span class="p">):</span>
        <span class="n">response</span><span class="o">.</span><span class="n">set_cookie</span><span class="p">(</span><span class="s2">&quot;account&quot;</span><span class="p">,</span> <span class="n">username</span><span class="p">,</span> <span class="n">secret</span><span class="o">=</span><span class="s1">&#39;some-secret-key&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">template</span><span class="p">(</span><span class="s2">&quot;&lt;p&gt;Welcome {{name}}! You are now logged in.&lt;/p&gt;&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">username</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;p&gt;Login failed.&lt;/p&gt;&quot;</span>

<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/restricted&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">restricted_area</span><span class="p">():</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">get_cookie</span><span class="p">(</span><span class="s2">&quot;account&quot;</span><span class="p">,</span> <span class="n">secret</span><span class="o">=</span><span class="s1">&#39;some-secret-key&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">username</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">template</span><span class="p">(</span><span class="s2">&quot;Hello {{name}}. Welcome back.&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">username</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;You are not logged in. Access denied.&quot;</span>
</pre></div>
</div>
<p>이에 더해 보틀에선 서명된 쿠키에 저장된 데이터를 자동으로 pickle 및 unpickle 해 준다. 즉 pickle 한 데이터가 4 KB 제한을 넘지 않는 한 (문자열만이 아니라) pickle 가능한 어떤 객체든 쿠키에 저장할 수 있다.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>서명된 쿠키가 암호화되는 건 아니다. (클라이언트가 여전히 내용물을 볼 수 있다.) 그리고 복사 방지가 되는 것도 않다. (클라이언트가 이전 쿠키를 재사용할 수 있다.) 주된 의도는 pickle 처리를 안전하게 만들고 조작을 막는 것이지, 클라이언트 쪽에 비밀 정보를 저장하는 게 아니다.</p>
</div>
</div>
</div>
<div class="section" id="tutorial-request">
<span id="id16"></span><h2>요청 데이터<a class="headerlink" href="#tutorial-request" title="Permalink to this headline">¶</a></h2>
<p>전역 <a class="reference internal" href="api.html#id0" title="bottle.request"><code class="xref py py-data docutils literal notranslate"><span class="pre">request</span></code></a> 객체를 통해 쿠키, HTTP 헤더, HTML <code class="docutils literal notranslate"><span class="pre">&lt;form&gt;</span></code> 필드, 기타 요청 데이터를 이용할 수 있다. 이 특수 객체는 여러 클라이언트 연결을 동시에 처리하는 다중 스레드 환경에서도  항상 <em>현재</em> 요청을 가리킨다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bottle</span> <span class="kn">import</span> <span class="n">request</span><span class="p">,</span> <span class="n">route</span><span class="p">,</span> <span class="n">template</span>

<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/hello&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">cookies</span><span class="o">.</span><span class="n">username</span> <span class="ow">or</span> <span class="s1">&#39;Guest&#39;</span>
    <span class="k">return</span> <span class="n">template</span><span class="p">(</span><span class="s1">&#39;Hello {{name}}&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="api.html#id0" title="bottle.request"><code class="xref py py-data docutils literal notranslate"><span class="pre">request</span></code></a> 객체는 <a class="reference internal" href="api.html#bottle.BaseRequest" title="bottle.BaseRequest"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseRequest</span></code></a>의 서브클래스이며 데이터 접근을 위한 풍부한 API가 있다. 여기선 자주 쓰는 것들만 다루는데, 처음엔 이걸로 충분할 것이다.</p>
<div class="section" id="formsdict">
<h3><a class="reference internal" href="api.html#bottle.FormsDict" title="bottle.FormsDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">FormsDict</span></code></a> 소개<a class="headerlink" href="#formsdict" title="Permalink to this headline">¶</a></h3>
<p>보틀에선 특별한 딕셔너리를 이용해 양식 데이터와 쿠키를 저장한다. <a class="reference internal" href="api.html#bottle.FormsDict" title="bottle.FormsDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">FormsDict</span></code></a>는 보통 딕셔너리처럼 동작하면서 거기 더해 개발을 편하게 해 주는 기능이 몇 가지 있다.</p>
<p><strong>속성 접근:</strong> 딕셔너리의 모든 값들을 속성으로도 접근할 수 있다. 그 가상 속성들은 유니코드열을 반환하는데, 값이 없거나 유니코드 디코딩이 실패한 경우도 마찬가지다. 그 경우 문자열이 비어 있지만 존재는 한다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">cookies</span><span class="o">.</span><span class="n">name</span>

<span class="c1"># 풀어 쓰면 다음과 같고:</span>

<span class="n">name</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">cookies</span><span class="o">.</span><span class="n">getunicode</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span> <span class="c1"># encoding=&#39;utf-8&#39; (기본)</span>

<span class="c1"># 기본적으로 다음을 하는 것이다:</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">cookies</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">UnicodeError</span><span class="p">:</span>
    <span class="n">name</span> <span class="o">=</span> <span class="sa">u</span><span class="s1">&#39;&#39;</span>
</pre></div>
</div>
<p><strong>키별로 여러 값:</strong>: <a class="reference internal" href="api.html#bottle.FormsDict" title="bottle.FormsDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">FormsDict</span></code></a>가 <a class="reference internal" href="api.html#bottle.MultiDict" title="bottle.MultiDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiDict</span></code></a>의 서브클래스이므로 키별로 여러 값을 저장할 수 있다. 표준 딕셔너리 접근 메소드는 값 한 개만 반환하지만 <a class="reference internal" href="api.html#bottle.MultiDict.getall" title="bottle.MultiDict.getall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getall()</span></code></a> 메소드는 해당 키에 대한 모든 값들의 (비어 있을 수도 있는) 리스트를 반환한다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">choice</span> <span class="ow">in</span> <span class="n">request</span><span class="o">.</span><span class="n">forms</span><span class="o">.</span><span class="n">getall</span><span class="p">(</span><span class="s1">&#39;multiple_choice&#39;</span><span class="p">):</span>
    <span class="n">do_something</span><span class="p">(</span><span class="n">choice</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>WTForms 지원:</strong> 어떤 라이브러리(예: <a class="reference external" href="http://wtforms.simplecodes.com/">WTForms</a>)는 입력으로 유니코드로만 된 딕셔너리를 원한다. <a class="reference internal" href="api.html#bottle.FormsDict.decode" title="bottle.FormsDict.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FormsDict.decode()</span></code></a>가 일을 대신 해 준다. 즉 모든 값들을 디코딩해서 각각의 사본들을 반환하면서 키별 여러 값 및 기타 모든 특성을 유지한다.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>파이썬 2</strong>에선 키와 값이 모두 바이트열이다. 유니코드가 필요하면 <a class="reference internal" href="api.html#bottle.FormsDict.getunicode" title="bottle.FormsDict.getunicode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FormsDict.getunicode()</span></code></a>를 호출하거나 속성 접근을 통해 값을 얻을 수 있다. 두 방법 모두 문자열 디코딩(기본값: utf8)을 시도하며 실패 시 빈 문자열을 반환한다. <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#UnicodeError" title="(in Python v3.9)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a>를 잡을 필요가 없다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">query</span><span class="p">[</span><span class="s1">&#39;city&#39;</span><span class="p">]</span>
<span class="go">&#39;G\xc3\xb6ttingen&#39;  # utf8 바이트열</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">city</span>
<span class="go">u&#39;Göttingen&#39;        # 같은 내용의 유니코드열</span>
</pre></div>
</div>
<p><strong>파이썬 3</strong>에선 모든 문자열이 유니코드지만 HTTP는 바이트 기반 프로토콜이다. 응용으로 전달하기 전에 서버에서 어떻게든 바이트열을 디코딩해야 한다. WSGI에선 ISO-8859-1(즉 latin1)을 제안하는데, 이후 다른 인코딩으로 재인코딩할 수도 있는 가역적 단일 바이트 코덱이다. 보틀에선 <a class="reference internal" href="api.html#bottle.FormsDict.getunicode" title="bottle.FormsDict.getunicode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FormsDict.getunicode()</span></code></a>와 속성 접근 때는 재인코딩을 하지만 딕셔너리 접근 메소드에서는 하지 않는다. 그 경우엔 서버 구현에서 제공한 값을 그대로 반환하는데, 아마 원하는 값이 아닐 것이다.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">query</span><span class="p">[</span><span class="s1">&#39;city&#39;</span><span class="p">]</span>
<span class="go">&#39;GÃ¶ttingen&#39; # 서버가 임시로 ISO-8859-1로 디코딩한 utf8 문자열</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">city</span>
<span class="go">&#39;Göttingen&#39;  # 보틀이 utf8로 제대로 재인코딩한 동일 문자열</span>
</pre></div>
</div>
<p>값들이 올바로 디코딩된 딕셔너리 전체가 필요한 경우 (가령 WTForms에 사용) <a class="reference internal" href="api.html#bottle.FormsDict.decode" title="bottle.FormsDict.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FormsDict.decode()</span></code></a>를 호출해서 재인코딩된 사본을 얻을 수 있다.</p>
</div>
</div>
<div class="section" id="id17">
<h3>쿠키<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<p>쿠키는 클라이언트 브라우저에 저장되는 작은 텍스트 조각이며 요청마다 서버로 다시 전송된다. 단일 요청을 넘어 어떤 상태를 유지하는 데 유용하지만 (HTTP 자체는 무상태 프로토콜이다.) 보안 관련 문제에는 쓰지 않는 게 좋다. 클라이언트에서 손쉽게 위조할 수 있다.</p>
<p><a class="reference internal" href="api.html#bottle.BaseRequest.cookies" title="bottle.BaseRequest.cookies"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BaseRequest.cookies</span></code></a>(<a class="reference internal" href="api.html#bottle.FormsDict" title="bottle.FormsDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">FormsDict</span></code></a> 인스턴스)를 통해 클라이언트가 보낸 모든 쿠키를 이용할 수 있다. 다음 예는 간단한 쿠키 기반 조회수 카운터다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bottle</span> <span class="kn">import</span> <span class="n">route</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">response</span>
<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/counter&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">counter</span><span class="p">():</span>
    <span class="n">count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">request</span><span class="o">.</span><span class="n">cookies</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;counter&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">response</span><span class="o">.</span><span class="n">set_cookie</span><span class="p">(</span><span class="s1">&#39;counter&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
    <span class="k">return</span> <span class="s1">&#39;You visited this page </span><span class="si">%d</span><span class="s1"> times&#39;</span> <span class="o">%</span> <span class="n">count</span>
</pre></div>
</div>
<p><a class="reference internal" href="api.html#bottle.BaseRequest.get_cookie" title="bottle.BaseRequest.get_cookie"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseRequest.get_cookie()</span></code></a> 메소드는 쿠키에 접근하는 또 다른 방법이다. 다른 절에서 설명한 것처럼 <a class="reference internal" href="#tutorial-signed-cookies"><span class="std std-ref">서명된 쿠키</span></a> 디코딩을 지원한다.</p>
</div>
<div class="section" id="id18">
<h3>HTTP 헤더<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<p>클라이언트가 보낸 모든 HTTP 헤더(예: <code class="docutils literal notranslate"><span class="pre">Referer</span></code>, <code class="docutils literal notranslate"><span class="pre">Agent</span></code>, <code class="docutils literal notranslate"><span class="pre">Accept-Language</span></code>)가 <a class="reference internal" href="api.html#bottle.WSGIHeaderDict" title="bottle.WSGIHeaderDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">WSGIHeaderDict</span></code></a>에 저장되어 <a class="reference internal" href="api.html#bottle.BaseRequest.headers" title="bottle.BaseRequest.headers"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BaseRequest.headers</span></code></a> 속성을 통해 접근할 수 있다. <a class="reference internal" href="api.html#bottle.WSGIHeaderDict" title="bottle.WSGIHeaderDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">WSGIHeaderDict</span></code></a>는 기본적으로 키에 대소문자 구별이 없는 딕셔너리다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bottle</span> <span class="kn">import</span> <span class="n">route</span><span class="p">,</span> <span class="n">request</span>
<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/is_ajax&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">is_ajax</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">headers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;X-Requested-With&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;XMLHttpRequest&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;This is an AJAX request&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;This is a normal request&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h3>질의 변수<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<p>서버로 키/값 짝 몇 개를 보내는 데 (<code class="docutils literal notranslate"><span class="pre">/forum?id=1&amp;page=5</span></code> 같은) 질의 문자열을 쓰는 경우가 많다. <a class="reference internal" href="api.html#bottle.BaseRequest.query" title="bottle.BaseRequest.query"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BaseRequest.query</span></code></a> 속성(<a class="reference internal" href="api.html#bottle.FormsDict" title="bottle.FormsDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">FormsDict</span></code></a> 인스턴스)으로 그 값들에 접근할 수 있고 <a class="reference internal" href="api.html#bottle.BaseRequest.query_string" title="bottle.BaseRequest.query_string"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BaseRequest.query_string</span></code></a> 속성으로 문자열 전체를 얻을 수 있다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bottle</span> <span class="kn">import</span> <span class="n">route</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">template</span>
<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/forum&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">display_forum</span><span class="p">():</span>
    <span class="n">forum_id</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">id</span>
    <span class="n">page</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">page</span> <span class="ow">or</span> <span class="s1">&#39;1&#39;</span>
    <span class="k">return</span> <span class="n">template</span><span class="p">(</span><span class="s1">&#39;Forum ID: {{id}} (page {{page}})&#39;</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">forum_id</span><span class="p">,</span> <span class="n">page</span><span class="o">=</span><span class="n">page</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="html-form">
<h3>HTML <cite>&lt;form&gt;</cite> 처리<a class="headerlink" href="#html-form" title="Permalink to this headline">¶</a></h3>
<p>기본부터 시작해 보자. HTML에서 <code class="docutils literal notranslate"><span class="pre">&lt;form&gt;</span></code>은 보통 다음처럼 생겼다.</p>
<div class="highlight-html notranslate"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">form</span> <span class="na">action</span><span class="o">=</span><span class="s">&quot;/login&quot;</span> <span class="na">method</span><span class="o">=</span><span class="s">&quot;post&quot;</span><span class="p">&gt;</span>
    Username: <span class="p">&lt;</span><span class="nt">input</span> <span class="na">name</span><span class="o">=</span><span class="s">&quot;username&quot;</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;text&quot;</span> <span class="p">/&gt;</span>
    Password: <span class="p">&lt;</span><span class="nt">input</span> <span class="na">name</span><span class="o">=</span><span class="s">&quot;password&quot;</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;password&quot;</span> <span class="p">/&gt;</span>
    <span class="p">&lt;</span><span class="nt">input</span> <span class="na">value</span><span class="o">=</span><span class="s">&quot;Login&quot;</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;submit&quot;</span> <span class="p">/&gt;</span>
<span class="p">&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">action</span></code> 속성이 양식 데이터를 받을 URL을 나타낸다. <code class="docutils literal notranslate"><span class="pre">method</span></code>는 사용할 HTTP 메소드(<code class="docutils literal notranslate"><span class="pre">GET</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">POST</span></code>)를 지정한다. <code class="docutils literal notranslate"><span class="pre">method=&quot;get&quot;</span></code>이면 양식 값들이 URL에 덧붙고 앞서 설명한 것처럼 <a class="reference internal" href="api.html#bottle.BaseRequest.query" title="bottle.BaseRequest.query"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BaseRequest.query</span></code></a>를 통해 이용할 수 있다. 하지만 이 방식은 안전하지 않은 데다 다른 제약들이 있고, 그래서 여기선 <code class="docutils literal notranslate"><span class="pre">method=&quot;post&quot;</span></code>를 쓴다. 긴가민가하면 <code class="docutils literal notranslate"><span class="pre">POST</span></code>를 쓰면 된다.</p>
<p><code class="docutils literal notranslate"><span class="pre">POST</span></code>를 통해 전송된 필드는 <a class="reference internal" href="api.html#bottle.FormsDict" title="bottle.FormsDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">FormsDict</span></code></a>인 <a class="reference internal" href="api.html#bottle.BaseRequest.forms" title="bottle.BaseRequest.forms"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BaseRequest.forms</span></code></a>에 저장된다. 서버 쪽 코드에서 다음처럼 값을 볼 수 있다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bottle</span> <span class="kn">import</span> <span class="n">route</span><span class="p">,</span> <span class="n">request</span>

<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/login&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">        &lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt;</span>
<span class="s1">            Username: &lt;input name=&quot;username&quot; type=&quot;text&quot; /&gt;</span>
<span class="s1">            Password: &lt;input name=&quot;password&quot; type=&quot;password&quot; /&gt;</span>
<span class="s1">            &lt;input value=&quot;Login&quot; type=&quot;submit&quot; /&gt;</span>
<span class="s1">        &lt;/form&gt;</span>
<span class="s1">    &#39;&#39;&#39;</span>

<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/login&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;POST&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">do_login</span><span class="p">():</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">forms</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;username&#39;</span><span class="p">)</span>
    <span class="n">password</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">forms</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;password&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">check_login</span><span class="p">(</span><span class="n">username</span><span class="p">,</span> <span class="n">password</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;p&gt;Your login information was correct.&lt;/p&gt;&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;p&gt;Login failed.&lt;/p&gt;&quot;</span>
</pre></div>
</div>
<p>양식 데이터에 접근하는 데 쓰는 속성들이 여러 가지 있다. 일부는 편리한 접근을 위해 여러 출처의 값들을 합친다. 요약하면 다음 표와 같다.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 38%" />
<col style="width: 21%" />
<col style="width: 23%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>속성</p></th>
<th class="head"><p>GET 양식 필드</p></th>
<th class="head"><p>POST 양식 필드</p></th>
<th class="head"><p>파일 업로드</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="api.html#bottle.BaseRequest.query" title="bottle.BaseRequest.query"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BaseRequest.query</span></code></a></p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="api.html#bottle.BaseRequest.forms" title="bottle.BaseRequest.forms"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BaseRequest.forms</span></code></a></p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="api.html#bottle.BaseRequest.files" title="bottle.BaseRequest.files"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BaseRequest.files</span></code></a></p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="api.html#bottle.BaseRequest.params" title="bottle.BaseRequest.params"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BaseRequest.params</span></code></a></p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="api.html#bottle.BaseRequest.GET" title="bottle.BaseRequest.GET"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BaseRequest.GET</span></code></a></p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="api.html#bottle.BaseRequest.POST" title="bottle.BaseRequest.POST"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BaseRequest.POST</span></code></a></p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id20">
<h3>파일 업로드<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h3>
<p>파일 업로드를 지원하려면 <code class="docutils literal notranslate"><span class="pre">&lt;form&gt;</span></code> 태그를 살짝 바꿔야 한다. 먼저 <code class="docutils literal notranslate"><span class="pre">&lt;form&gt;</span></code> 태그에 <code class="docutils literal notranslate"><span class="pre">enctype=&quot;multipart/form-data&quot;</span></code> 속성을 추가해서 브라우저가 양식 데이터를 다른 방식으로 인코딩하게 한다. 다음으로 <code class="docutils literal notranslate"><span class="pre">&lt;input</span> <span class="pre">type=&quot;file&quot;</span> <span class="pre">/&gt;</span></code> 태그를 추가해서 사용자가 파일을 선택할 수 있게 한다. 예는 다음과 같다.</p>
<div class="highlight-html notranslate"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">form</span> <span class="na">action</span><span class="o">=</span><span class="s">&quot;/upload&quot;</span> <span class="na">method</span><span class="o">=</span><span class="s">&quot;post&quot;</span> <span class="na">enctype</span><span class="o">=</span><span class="s">&quot;multipart/form-data&quot;</span><span class="p">&gt;</span>
  Category:      <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;text&quot;</span> <span class="na">name</span><span class="o">=</span><span class="s">&quot;category&quot;</span> <span class="p">/&gt;</span>
  Select a file: <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;file&quot;</span> <span class="na">name</span><span class="o">=</span><span class="s">&quot;upload&quot;</span> <span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;submit&quot;</span> <span class="na">value</span><span class="o">=</span><span class="s">&quot;Start upload&quot;</span> <span class="p">/&gt;</span>
<span class="p">&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>업로드된 파일을 보틀에서 몇 가지 메타데이터와 함께 <a class="reference internal" href="api.html#bottle.BaseRequest.files" title="bottle.BaseRequest.files"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BaseRequest.files</span></code></a>에 <a class="reference internal" href="api.html#bottle.FileUpload" title="bottle.FileUpload"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileUpload</span></code></a> 인스턴스로 저장한다. 그 파일을 그냥 디스크에 저장하고 싶다고 해 보자.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/upload&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;POST&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">do_upload</span><span class="p">():</span>
    <span class="n">category</span>   <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">forms</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>
    <span class="n">upload</span>     <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">files</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;upload&#39;</span><span class="p">)</span>
    <span class="n">name</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">upload</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ext</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;.png&#39;</span><span class="p">,</span><span class="s1">&#39;.jpg&#39;</span><span class="p">,</span><span class="s1">&#39;.jpeg&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;File extension not allowed.&#39;</span>

    <span class="n">save_path</span> <span class="o">=</span> <span class="n">get_save_path_for_category</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
    <span class="n">upload</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">save_path</span><span class="p">)</span> <span class="c1"># upload.filename을 자동으로 덧붙임</span>
    <span class="k">return</span> <span class="s1">&#39;OK&#39;</span>
</pre></div>
</div>
<p><a class="reference internal" href="api.html#bottle.FileUpload.filename" title="bottle.FileUpload.filename"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FileUpload.filename</span></code></a>은 클라이언트 파일 시스템 상의 파일 이름을 담는데, 파일명 안의 지원 안 되는 문자 내지 경로 분절로 인한 버그를 막기 위해 정리 및 정규화가 돼 있다. 클라이언트가 보낸 변경 안 된 이름이 필요하다면 <a class="reference internal" href="api.html#bottle.FileUpload.raw_filename" title="bottle.FileUpload.raw_filename"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FileUpload.raw_filename</span></code></a>을 보면 된다.</p>
<p>파일을 디스크에 저장하려는 거라면 <a class="reference internal" href="api.html#bottle.FileUpload.save" title="bottle.FileUpload.save"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FileUpload.save</span></code></a> 메소드를 적극 권한다. 몇 가지 흔한 오류들을 방지해 주며 (가령 따로 명시하지 않으면 기존 파일을 덮어 쓰지 않는다.) 메모리에서 파일을 효율적인 방식으로 저장한다. <a class="reference internal" href="api.html#bottle.FileUpload.file" title="bottle.FileUpload.file"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FileUpload.file</span></code></a>을 통해 파일 객체에 바로 접근할 수 있다. 단 조심하자.</p>
</div>
<div class="section" id="id21">
<h3>JSON 내용물<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h3>
<p>일부 자바스크립트나 REST 클라이언트는 서버로 <code class="docutils literal notranslate"><span class="pre">application/json</span></code> 내용물을 보낸다. 파싱 가능한 경우 <a class="reference internal" href="api.html#bottle.BaseRequest.json" title="bottle.BaseRequest.json"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BaseRequest.json</span></code></a> 속성에 파싱된 자료 구조가 들어 있다.</p>
</div>
<div class="section" id="id22">
<h3>비가공 요청 바디<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="api.html#bottle.BaseRequest.body" title="bottle.BaseRequest.body"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BaseRequest.body</span></code></a>를 통해 가공 안 된 바디 데이터를 파일스러운 객체로 접근할 수 있다. 내용물 길이 및 <a class="reference internal" href="api.html#bottle.BaseRequest.MEMFILE_MAX" title="bottle.BaseRequest.MEMFILE_MAX"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BaseRequest.MEMFILE_MAX</span></code></a> 설정에 따라서 <code class="xref py py-class docutils literal notranslate"><span class="pre">BytesIO</span></code> 버퍼거나 임시 파일이다. 두 경우 모두 바디가 버퍼에 완전히 저장된 다음에 그 속성에 접근할 수 있다. 데이터가 거대할 것으로 예상되는데 스트림에 버퍼 없이 바로 접근하고 싶다면 <code class="docutils literal notranslate"><span class="pre">request['wsgi.input']</span></code>을 살펴보라.</p>
</div>
<div class="section" id="wsgi">
<h3>WSGI 환경<a class="headerlink" href="#wsgi" title="Permalink to this headline">¶</a></h3>
<p>각 <a class="reference internal" href="api.html#bottle.BaseRequest" title="bottle.BaseRequest"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseRequest</span></code></a> 인스턴스는 WSGI 환경 딕셔너리를 감싸고 있다. 원본은 <a class="reference internal" href="api.html#bottle.BaseRequest.environ" title="bottle.BaseRequest.environ"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BaseRequest.environ</span></code></a>에 저장되지만 요청 객체 자체가 딕셔너리처럼 동작하기도 한다. 많이 쓰는 데이터 대부분이 특수한 메소드나 속성을 통해 노출돼 있지만 <a class="reference external" href="WSGIspecification">WSGI 환경 변수</a>에 직접 접근하고 싶다면 그럴 수도 있다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/my_ip&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show_ip</span><span class="p">():</span>
    <span class="n">ip</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;REMOTE_ADDR&#39;</span><span class="p">)</span>
    <span class="c1"># 또는 ip = request.get(&#39;REMOTE_ADDR&#39;)</span>
    <span class="c1"># 또는 ip = request[&#39;REMOTE_ADDR&#39;]</span>
    <span class="k">return</span> <span class="n">template</span><span class="p">(</span><span class="s2">&quot;Your IP is: {{ip}}&quot;</span><span class="p">,</span> <span class="n">ip</span><span class="o">=</span><span class="n">ip</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="tutorial-templates">
<span id="id24"></span><h2>템플릿<a class="headerlink" href="#tutorial-templates" title="Permalink to this headline">¶</a></h2>
<p>보틀에는 <a class="reference internal" href="stpl.html"><span class="doc">SimpleTemplate 엔진</span></a>이라는 빠르고 강력한 내장 템플릿 엔진이 딸려 있다. <a class="reference internal" href="api.html#bottle.template" title="bottle.template"><code class="xref py py-func docutils literal notranslate"><span class="pre">template()</span></code></a> 함수나 <a class="reference internal" href="api.html#bottle.view" title="bottle.view"><code class="xref py py-func docutils literal notranslate"><span class="pre">view()</span></code></a> 데코레이터를 써서 템플릿을 렌더링할 수 있다. 템플릿 이름을 적고 템플릿에 전달하고 싶은 변수들을 키워드 인자로 주기만 하면 된다. 다음은 간단한 템플릿 렌더링 예시다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/hello&#39;</span><span class="p">)</span>
<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/hello/&lt;name&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;World&#39;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">template</span><span class="p">(</span><span class="s1">&#39;hello_template&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>템플릿 파일 <code class="docutils literal notranslate"><span class="pre">hello_template.tpl</span></code>을 읽어 들여서 <code class="docutils literal notranslate"><span class="pre">name</span></code> 변수를 설정해서 렌더링한다. <code class="docutils literal notranslate"><span class="pre">./views/</span></code> 폴더 또는 <code class="docutils literal notranslate"><span class="pre">bottle.TEMPLATE_PATH</span></code> 목록에 지정된 모든 폴더에서 템플릿을 찾게 된다.</p>
<p><a class="reference internal" href="api.html#bottle.view" title="bottle.view"><code class="xref py py-func docutils literal notranslate"><span class="pre">view()</span></code></a> 데코레이터를 쓰면 <a class="reference internal" href="api.html#bottle.template" title="bottle.template"><code class="xref py py-func docutils literal notranslate"><span class="pre">template()</span></code></a>을 호출하는 게 아니라 템플릿 변수들을 담은 딕셔너리를 반환하는 방식이 가능하다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/hello&#39;</span><span class="p">)</span>
<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/hello/&lt;name&gt;&#39;</span><span class="p">)</span>
<span class="nd">@view</span><span class="p">(</span><span class="s1">&#39;hello_template&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;World&#39;</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">문법</p>
<p>템플릿 문법은 파이썬 언어 위에 씌운 아주 얇은 층이다. 주된 목적은 블록 들여쓰기가 올바로 이뤄지게 해서 들여쓰기에 신경쓰지 않고 템플릿을 작성할 수 있게 하는 것이다. 전체 문법 설명은 <a class="reference internal" href="stpl.html"><span class="doc">SimpleTemplate 엔진</span></a> 참고.</p>
<p>다음은 템플릿 예시다.</p>
<div class="highlight-html+django notranslate"><div class="highlight"><pre><span></span>%if name == &#39;World&#39;:
    <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>Hello <span class="cp">{{</span><span class="nv">name</span><span class="cp">}}</span>!<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>This is a test.<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
%else:
    <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>Hello <span class="cp">{{</span><span class="nv">name.title</span><span class="o">()</span><span class="cp">}}</span>!<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>How are you?<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
%end
</pre></div>
</div>
<p class="rubric">캐싱</p>
<p>템플릿은 컴파일 후 메모리 내에 캐싱된다. 템플릿 파일에 변경을 해도 템플릿 캐시를 비우기 전에는 효과가 없게 된다. 비우려면 <code class="docutils literal notranslate"><span class="pre">bottle.TEMPLATES.clear()</span></code>를 호출하면 된다. 디버그 모드에서는 캐싱이 꺼진다.</p>
</div>
<div class="section" id="plugins">
<span id="id25"></span><h2>플러그인<a class="headerlink" href="#plugins" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.9.</span></p>
</div>
<p>보틀의 핵심 기능들이 흔한 사용 방식을 대부분 포괄하지만 마이크로 프레임워크라서 한계가 있다. 이때 “플러그인”이 역할을 할 수 있다. 플러그인은 프레임워크에 빠진 기능성을 더하거나, 서드파티 라이브러리를 연결하거나, 어떤 반복 작업을 자동화해 준다.</p>
<p><a class="reference internal" href="plugins/index.html"><span class="doc">사용 가능한 플러그인들</span></a>이 점점 늘어나고 있으며 대다수 플러그인들이 응용들 간에 이식성 있고 재사용 가능하도록 설계돼 있다. 뭔가 해결할 문제가 있다면 이미 해결돼서 바로 쓸 수 있는 플러그인이 존재할 가능성이 높다. 아니라면 <a class="reference internal" href="plugindev.html"><span class="doc">플러그인 개발 안내서</span></a>가 도움이 될 수 있다.</p>
<p>플러그인의 효과와 API는 다종다양하고 플러그인에 따라 다르다. 예를 들어 <code class="docutils literal notranslate"><span class="pre">SQLitePlugin</span></code> 플러그인은 <code class="docutils literal notranslate"><span class="pre">db</span></code> 키워드 인자가 있는 콜백들을 탐지해서 콜백이 호출될 때마다 새로운 데이터베이스 연결 객체를 만들어 준다. 그래서 데이터베이스 사용이 아주 편리해진다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bottle</span> <span class="kn">import</span> <span class="n">route</span><span class="p">,</span> <span class="n">install</span><span class="p">,</span> <span class="n">template</span>
<span class="kn">from</span> <span class="nn">bottle_sqlite</span> <span class="kn">import</span> <span class="n">SQLitePlugin</span>

<span class="n">install</span><span class="p">(</span><span class="n">SQLitePlugin</span><span class="p">(</span><span class="n">dbfile</span><span class="o">=</span><span class="s1">&#39;/tmp/test.db&#39;</span><span class="p">))</span>

<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/show/&lt;post_id:int&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">post_id</span><span class="p">):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;SELECT title, content FROM posts WHERE id = ?&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">post_id</span><span class="p">,))</span>
    <span class="n">row</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">template</span><span class="p">(</span><span class="s1">&#39;show_post&#39;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">],</span> <span class="n">text</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;content&#39;</span><span class="p">])</span>

<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/contact&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">contact_page</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39; 이 콜백에선 db 연결이 필요치 않다. &#39;db&#39; 키워드 인자가</span>
<span class="sd">        없으므로 sqlite 플러그인에서 이 콜백을 완전히 무시한다. &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">template</span><span class="p">(</span><span class="s1">&#39;contact&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>다른 플러그인에서는 스레드에 안전한 <code class="xref py py-data docutils literal notranslate"><span class="pre">local</span></code> 객체를 만들어 주거나, <a class="reference internal" href="api.html#id0" title="bottle.request"><code class="xref py py-data docutils literal notranslate"><span class="pre">request</span></code></a> 객체의 세부 내용을 바꾸거나, 콜백이 반환한 데이터를 필터링하거나, 콜백을 완전히 건너뛸 수도 있다. 예를 들어 “auth” 플러그인에서 유효한 세션인지 검사해서 원래 콜백을 호출하지 않고 로그인 페이지를 반환할 수도 있다. 정확히 어떤 일이 일어나는지는 플러그인에 달려 있다.</p>
<div class="section" id="id26">
<h3>응용 전체 설치<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h3>
<p>플러그인을 응용 전체에 설치할 수도 있고 추가 기능이 필요한 특정 라우트에만 설치할 수도 있다. 대부분의 플러그인은 모든 라우트에 설치해도 안전하며 그 기능이 필요치 않은 콜백에 오버헤드를 더하지 않을 만큼 똑똑하다.</p>
<p><code class="docutils literal notranslate"><span class="pre">SQLitePlugin</span></code> 플러그인을 예로 들어 보자. 이 플러그인은 데이터베이스 연결이 필요한 라우트 콜백에만 영향을 준다. 다른 라우트는 그대로 둔다. 그래서 추가 오버헤드 없이 응용 전체에 플러그인을 설치할 수 있다.</p>
<p>플러그인을 설치하려면 플러그인을 첫 인자로 해서 <code class="xref py py-func docutils literal notranslate"><span class="pre">install()</span></code>을 호출하면 된다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bottle_sqlite</span> <span class="kn">import</span> <span class="n">SQLitePlugin</span>
<span class="n">install</span><span class="p">(</span><span class="n">SQLitePlugin</span><span class="p">(</span><span class="n">dbfile</span><span class="o">=</span><span class="s1">&#39;/tmp/test.db&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>아직 라우트 콜백에 플러그인이 적용돼 있지 않다. 놓치는 라우트가 없도록 하기 위해 적용을 늦춘다. 그래서 원한다면 플러그인들을 먼저 설치하고 나서 라우트를 추가할 수 있다. 그런데 설치되는 플러그인들의 순서는 중요하다. 어떤 플러그인에서 데이터베이스 연결이 필요하다면 데이터베이스 플러그인을 먼저 설치해야 한다.</p>
<p class="rubric">플러그인 제거</p>
<p>이름이나 클래스, 인스턴스를 써서 앞서 설치한 플러그인을 <code class="xref py py-func docutils literal notranslate"><span class="pre">uninstall()</span></code> 할 수 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sqlite_plugin</span> <span class="o">=</span> <span class="n">SQLitePlugin</span><span class="p">(</span><span class="n">dbfile</span><span class="o">=</span><span class="s1">&#39;/tmp/test.db&#39;</span><span class="p">)</span>
<span class="n">install</span><span class="p">(</span><span class="n">sqlite_plugin</span><span class="p">)</span>

<span class="n">uninstall</span><span class="p">(</span><span class="n">sqlite_plugin</span><span class="p">)</span> <span class="c1"># 특정 플러그인 제거</span>
<span class="n">uninstall</span><span class="p">(</span><span class="n">SQLitePlugin</span><span class="p">)</span>  <span class="c1"># 그 타입의 모든 플러그인 제거</span>
<span class="n">uninstall</span><span class="p">(</span><span class="s1">&#39;sqlite&#39;</span><span class="p">)</span>      <span class="c1"># 그 이름의 모든 플러그인 제거</span>
<span class="n">uninstall</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>          <span class="c1"># 모든 플러그인 한꺼번에 제거</span>
</pre></div>
</div>
<p>언제든 플러그인을 설치하고 제거할 수 있다. 요청을 처리 중인 런타임에도 가능하다. 이를 이용하면 멋진 기술(느린 디버깅 내지 프로파일링 플러그인을 필요할 때만 설치하기)이 가능하긴 하지만 남용하진 말자. 플러그인 목록이 바뀔 때마다 라우트 캐시가 비워지고 모든 플러그인들이 재적용된다.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>모듈 층위의 <code class="xref py py-func docutils literal notranslate"><span class="pre">install()</span></code> 및 <code class="xref py py-func docutils literal notranslate"><span class="pre">uninstall()</span></code> 함수는 <a class="reference internal" href="#default-app"><span class="std std-ref">기본 응용</span></a>에 효력이 있다. 특정 응용의 플러그인을 관리하려면 <a class="reference internal" href="api.html#bottle.Bottle" title="bottle.Bottle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bottle</span></code></a> 응용 객체의 대응 메소드를 쓰면 된다.</p>
</div>
</div>
<div class="section" id="id27">
<h3>라우트 한정 설치<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h3>
<p>일부 라우트에만 플러그인을 설치하고 싶다면 <a class="reference internal" href="api.html#bottle.route" title="bottle.route"><code class="xref py py-func docutils literal notranslate"><span class="pre">route()</span></code></a> 데코레이터의 <code class="docutils literal notranslate"><span class="pre">apply</span></code> 매개변수를 쓸 수 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sqlite_plugin</span> <span class="o">=</span> <span class="n">SQLitePlugin</span><span class="p">(</span><span class="n">dbfile</span><span class="o">=</span><span class="s1">&#39;/tmp/test.db&#39;</span><span class="p">)</span>

<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/create&#39;</span><span class="p">,</span> <span class="n">apply</span><span class="o">=</span><span class="p">[</span><span class="n">sqlite_plugin</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="n">db</span><span class="p">):</span>
    <span class="n">db</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;INSERT INTO ...&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id28">
<h3>플러그인 차단 목록<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h3>
<p>일부 라우트에서 어떤 플러그인을 명시적으로 비활성화하고 싶을 수도 있다. 그런 용도로 <a class="reference internal" href="api.html#bottle.route" title="bottle.route"><code class="xref py py-func docutils literal notranslate"><span class="pre">route()</span></code></a> 데코레이터에 <code class="docutils literal notranslate"><span class="pre">skip</span></code> 매개변수가 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sqlite_plugin</span> <span class="o">=</span> <span class="n">SQLitePlugin</span><span class="p">(</span><span class="n">dbfile</span><span class="o">=</span><span class="s1">&#39;/tmp/test1.db&#39;</span><span class="p">)</span>
<span class="n">install</span><span class="p">(</span><span class="n">sqlite_plugin</span><span class="p">)</span>

<span class="n">dbfile1</span> <span class="o">=</span> <span class="s1">&#39;/tmp/test1.db&#39;</span>
<span class="n">dbfile2</span> <span class="o">=</span> <span class="s1">&#39;/tmp/test2.db&#39;</span>

<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/open/&lt;db&gt;&#39;</span><span class="p">,</span> <span class="n">skip</span><span class="o">=</span><span class="p">[</span><span class="n">sqlite_plugin</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">open_db</span><span class="p">(</span><span class="n">db</span><span class="p">):</span>
    <span class="c1"># 이때는 플러그인이 &#39;db&#39; 키워드 인자를 건드리지 않는다.</span>

    <span class="c1"># 플러그인 핸들을 써서 런타임 설정을 할 수도 있다.</span>
    <span class="k">if</span> <span class="n">db</span> <span class="o">==</span> <span class="s1">&#39;test1&#39;</span><span class="p">:</span>
        <span class="n">sqlite_plugin</span><span class="o">.</span><span class="n">dbfile</span> <span class="o">=</span> <span class="n">dbfile1</span>
    <span class="k">elif</span> <span class="n">db</span> <span class="o">==</span> <span class="s1">&#39;test2&#39;</span><span class="p">:</span>
        <span class="n">sqlite_plugin</span><span class="o">.</span><span class="n">dbfile</span> <span class="o">=</span> <span class="n">dbfile2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">abort</span><span class="p">(</span><span class="mi">404</span><span class="p">,</span> <span class="s2">&quot;No such database.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="s2">&quot;Database File switched to: &quot;</span> <span class="o">+</span> <span class="n">sqlite_plugin</span><span class="o">.</span><span class="n">dbfile</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">skip</span></code> 매개변수는 단일 값 또는 값들의 리스트를 받는다. 이름, 클래스, 인스턴스를 사용해 건너뛸 플러그인을 지정할 수 있다. 모든 플러그인을 한꺼번에 건너뛰려면 <code class="docutils literal notranslate"><span class="pre">skip=True</span></code>로 설정하면 된다.</p>
</div>
<div class="section" id="id29">
<h3>플러그인과 하위 응용<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h3>
<p>대부분의 플러그인은 설치된 그 응용에서만 쓰기 위한 것이다. 따라서 <a class="reference internal" href="api.html#bottle.Bottle.mount" title="bottle.Bottle.mount"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Bottle.mount()</span></code></a>로 붙인 하위 응용에는 영향을 주지 않아야 한다. 다음 예를 보자.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">root</span> <span class="o">=</span> <span class="n">Bottle</span><span class="p">()</span>
<span class="n">root</span><span class="o">.</span><span class="n">mount</span><span class="p">(</span><span class="s1">&#39;/blog&#39;</span><span class="p">,</span> <span class="n">apps</span><span class="o">.</span><span class="n">blog</span><span class="p">)</span>

<span class="nd">@root</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/contact&#39;</span><span class="p">,</span> <span class="n">template</span><span class="o">=</span><span class="s1">&#39;contact&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">contact</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;email&#39;</span><span class="p">:</span> <span class="s1">&#39;contact@example.com&#39;</span><span class="p">}</span>

<span class="n">root</span><span class="o">.</span><span class="n">install</span><span class="p">(</span><span class="n">plugins</span><span class="o">.</span><span class="n">WTForms</span><span class="p">())</span>
</pre></div>
</div>
<p>응용을 마운트할 때마다 보틀에선 모든 요청을 하위 응용으로 전달해 주는 프록시 라우트를 주 응용에 만든다. 그런 프록시 라우트에 대해선 기본적으로 플러그인이 비활성화된다. 그래서 (가상의) <cite>WTForms</cite> 플러그인은 <code class="docutils literal notranslate"><span class="pre">/contact</span></code> 라우트에는 효과가 있지만 <code class="docutils literal notranslate"><span class="pre">/blog</span></code> 하위 응용의 라우트에는 영향을 주지 않는다.</p>
<p>이 적당한 기본 동작 방식을 바꿀 수도 있다. 다음 예는 특정 프록시 라우트에서 모든 플러그인을 재활성화한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">root</span><span class="o">.</span><span class="n">mount</span><span class="p">(</span><span class="s1">&#39;/blog&#39;</span><span class="p">,</span> <span class="n">apps</span><span class="o">.</span><span class="n">blog</span><span class="p">,</span> <span class="n">skip</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p>하지만 조심할 게 있다. 플러그인에겐 하위 응용 전체가 위의 프록시 라우트 하나로 보이게 된다. 하위 응용의 개별 라우트에 영향을 주려면 마운트된 응용에서 따로 플러그인을 설치해야 한다.</p>
</div>
</div>
<div class="section" id="id30">
<h2>개발<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h2>
<p>기초를 배웠으니 이제 응용을 작성하고 싶을 것이다. 아래 내용은 더 생산적으로
작업하는 데 도움이 될 수 있는 몇 가지 팁이다.</p>
<div class="section" id="default-app">
<span id="id31"></span><h3>기본 응용<a class="headerlink" href="#default-app" title="Permalink to this headline">¶</a></h3>
<p>보틀에선 전역으로 <a class="reference internal" href="api.html#bottle.Bottle" title="bottle.Bottle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bottle</span></code></a> 인스턴스들의 스택을 유지하고 최상단 인스턴스를 몇 가지 모듈 층위 함수와 데코레이터의 기본 인스턴스로 쓴다. 예를 들어 <a class="reference internal" href="api.html#bottle.route" title="bottle.route"><code class="xref py py-func docutils literal notranslate"><span class="pre">route()</span></code></a> 데코레이터는 기본 응용에 대한 <a class="reference internal" href="api.html#bottle.Bottle.route" title="bottle.Bottle.route"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Bottle.route()</span></code></a> 호출을 간략히 줄인 것이다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;Hello World&#39;</span>
</pre></div>
</div>
<p>작은 응용에서 아주 편리하고 키보드 입력을 좀 줄여 준다. 하지만 작성한 모듈을 임포트하면 전역 응용에 바로 라우트가 설치된다는 뜻이기도 하다. 그런 류의 임포트 부작용을 피하기 위해 보틀에선 응용을 구성하는 더 명시적인 방법을 제공한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">app</span> <span class="o">=</span> <span class="n">Bottle</span><span class="p">()</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;Hello World&#39;</span>
</pre></div>
</div>
<p>응용 객체를 분리하면 재사용성이 크게 향상되기도 한다. 다른 개발자가 이 모듈의 <code class="docutils literal notranslate"><span class="pre">app</span></code> 객체를 안전하게 임포트해서 <a class="reference internal" href="api.html#bottle.Bottle.mount" title="bottle.Bottle.mount"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Bottle.mount()</span></code></a>를 이용해 응용들을 합칠 수 있다.</p>
<p>아니면 응용 스택을 직접 사용해서 간편하게 작성하면서도 라우트들을 격리하는 것도 가능하다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">default_app</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>

<span class="nd">@route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;Hello World&#39;</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">default_app</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</pre></div>
</div>
<p><a class="reference internal" href="api.html#bottle.app" title="bottle.app"><code class="xref py py-func docutils literal notranslate"><span class="pre">app()</span></code></a>과 <a class="reference internal" href="api.html#bottle.default_app" title="bottle.default_app"><code class="xref py py-func docutils literal notranslate"><span class="pre">default_app()</span></code></a> 모두 <a class="reference internal" href="api.html#bottle.AppStack" title="bottle.AppStack"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppStack</span></code></a> 인스턴스이고 스택스러운 API를 구현하고 있다. 필요한 대로 그 스택에 응용을 밀어 넣거나 꺼낼 수 있다. 별도의 응용 객체를 제공하지 않는 서드파티 모듈을 임포트하려 할 때도 도움이 된다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">default_app</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>

<span class="kn">import</span> <span class="nn">some.module</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">default_app</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="tutorial-debugging">
<span id="id32"></span><h3>디버그 모드<a class="headerlink" href="#tutorial-debugging" title="Permalink to this headline">¶</a></h3>
<p>개발 초기에는 디버그 모드가 큰 도움이 될 수 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">bottle</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>이 모드에선 보틀에서 찍는 내용이 더 많아지고 오류가 발생했을 때 도움 되는 디버깅 정보를 제공한다. 방해가 될 수도 있는 몇몇 최적화를 끄고 설정 오류 가능성을 검사해서 경고하기도 한다.</p>
<p>다음은 디버그 모드에서 바뀌는 점들을 몇 가지 나열한 것이다.</p>
<ul class="simple">
<li><p>기본 오류 페이지에서 트레이스백을 보여 준다.</p></li>
<li><p>템플릿을 캐싱하지 않는다.</p></li>
<li><p>플러그인이 즉시 적용된다.</p></li>
</ul>
<p>운용 서버에서는 디버그 모드를 쓰지 않도록 하자.</p>
</div>
<div class="section" id="id33">
<h3>자동 재적재<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h3>
<p>개발 중에는 최근 바꾼 내용을 확인하기 위해 서버를 여러 번 재시작해야
한다. 자동 재적재 기능이 일을 덜어 줄 수 있다. 모듈 파일을 편집할
때마다 재적재 기능이 서버 프로세스를 재시작하고 코드 최신 버전을
적재한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bottle</span> <span class="kn">import</span> <span class="n">run</span>
<span class="n">run</span><span class="p">(</span><span class="n">reloader</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>어떻게 동작하는 걸까. 주 프로세스에서는 서버를 시작하는 게 아니라
주 프로세스 시작에 쓴 것과 같은 명령행 인자로 자식 프로세스를 새로
만든다. 모든 모듈 층위 코드가 최소 두 번 실행된다! 조심하자.</p>
<p>자식 프로세스는 <code class="docutils literal notranslate"><span class="pre">os.environ['BOTTLE_CHILD']</span></code>를 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 해서
재적재 동작 없는 일반 앱 서버로 시작한다. 적재된 모듈 어디에라도
변경이 발생하면 주 프로세스가 자식 프로세스를 끝내고 다시 만든다.
템플릿 파일 변경은 재적재를 일으키지 않는다. 템플릿 캐싱을
비활성화하고 싶으면 디버그 모드를 쓰면 된다.</p>
<p>재적재를 위해선 자식 프로세스를 중단시킬 수 있어야 한다. 윈도우나 기타
(파이썬에서 <code class="docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code>를 일으키는) <code class="docutils literal notranslate"><span class="pre">signal.SIGINT</span></code>를
지원하지 않는 운영 체제에서 돌고 있으면 <code class="docutils literal notranslate"><span class="pre">signal.SIGTERM</span></code>으로
자식을 죽인다. 참고로 <code class="docutils literal notranslate"><span class="pre">SIGTERM</span></code> 수신 후에는 종료 핸들러와 finally
구문 등이 실행되지 않는다.</p>
</div>
<div class="section" id="id34">
<h3>명령행 인터페이스<a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h3>
<p>버전 0.10부터 보틀을 명령행 도구처럼 쓸 수 있다.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>python -m bottle

<span class="go">Usage: bottle.py [options] package.module:app</span>

<span class="go">Options:</span>
<span class="go">  -h, --help            show this help message and exit</span>
<span class="go">  --version             show version number.</span>
<span class="go">  -b ADDRESS, --bind=ADDRESS</span>
<span class="go">                        bind socket to ADDRESS.</span>
<span class="go">  -s SERVER, --server=SERVER</span>
<span class="go">                        use SERVER as backend.</span>
<span class="go">  -p PLUGIN, --plugin=PLUGIN</span>
<span class="go">                        install additional plugin/s.</span>
<span class="go">  --debug               start server in debug mode.</span>
<span class="go">  --reload              auto-reload on file changes.</span>
</pre></div>
</div>
<p><cite>ADDRESS</cite> 필드는 IP 주소나 IP:PORT 짝을 받으며 기본은 <code class="docutils literal notranslate"><span class="pre">localhost:8080</span></code>이다. 다른 매개변수들은 따로 설명이 필요 없을 것이다.</p>
<p>플러그인과 응용 모두 임포트 식을 통해 지정한다. 임포트 경로(예: <code class="docutils literal notranslate"><span class="pre">package.module</span></code>)와 그 모듈 네임스페이스에서 평가할 식을 콜론으로 구분해서 쓴다. 자세한 건 <a class="reference internal" href="api.html#bottle.load" title="bottle.load"><code class="xref py py-func docutils literal notranslate"><span class="pre">load()</span></code></a> 참고. 다음이 예이다.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span><span class="s1">&#39;myapp.controller&#39;</span> 모듈에서 <span class="s1">&#39;app&#39;</span> 객체를 잡고,
<span class="gp"># </span>paste 서버를 전체 인터페이스 <span class="m">80</span> 포트에서 시작.
<span class="go">python -m bottle -server paste -bind 0.0.0.0:80 myapp.controller:app</span>

<span class="gp"># </span>자동 재적재하는 개발용 서버를 시작하고 전역 기본 응용 제공.
<span class="gp"># </span><span class="s1">&#39;test.py&#39;</span>에 라우트 정의돼 있음.
<span class="go">python -m bottle --debug --reload test</span>

<span class="gp"># </span>매개변수를 좀 줘서 자체 디버그 플러그인 설치.
<span class="go">python -m bottle --debug --reload --plugin &#39;utils:DebugPlugin(exc=True)&#39; test</span>

<span class="gp"># </span>요청에 따라 <span class="s1">&#39;myapp.controller.make_app()&#39;</span>으로 생성한 응용 제공.
<span class="go">python -m bottle &#39;myapp.controller:make_app()&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id35">
<h2>배치<a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h2>
<p>보틀은 기본적으로 내장 <a class="reference external" href="http://docs.python.org/library/wsgiref.html#module-wsgiref.simple_server">wsgiref WSGI 서버</a> 위에서 돈다. 스레드 없는 이 HTTP 서버가 개발 및 운용 초기에는 충분할 수 있겠지만 서버 부하가 커지면 성능 병목이 될 수 있다.</p>
<p>성능을 높이는 가장 쉬운 방법은 <a class="reference external" href="http://pythonpaste.org/">paste</a>나 <a class="reference external" href="http://www.cherrypy.org/">cherrypy</a> 같은 다중 스레드 서버 라이브러리를 설치하고 보틀에서 단일 스레드 서버 대신 쓰게 하는 것이다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">bottle</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">server</span><span class="o">=</span><span class="s1">&#39;paste&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>이 방식과 다른 배치 방식들을 <a class="reference internal" href="deployment.html"><span class="doc">배치</span></a> 글에서 따로 설명한다.</p>
</div>
<div class="section" id="tutorial-glossary">
<span id="id36"></span><h2>용어<a class="headerlink" href="#tutorial-glossary" title="Permalink to this headline">¶</a></h2>
<dl class="glossary simple">
<dt id="term-callback">콜백(callback)<a class="headerlink" href="#term-callback" title="Permalink to this term">¶</a></dt><dd><p>어떤 외부 행위가 일어났을 때 호출할 프로그래머가 작성한 코드.
웹 프레임워크에서는 각 URL에 콜백 함수를 지정하는 방식으로
URL 경로와 응용 코드 간에 매핑을 하는 경우가 많다.</p>
</dd>
<dt id="term-decorator">데코레이터(decorator)<a class="headerlink" href="#term-decorator" title="Permalink to this term">¶</a></dt><dd><p>다른 함수를 반환하는 함수. 일반적으로 <code class="docutils literal notranslate"><span class="pre">&#64;decorator</span></code> 문법으로 함수를 변환하는 데 쓴다. 데코레이터에 대한 자세한 내용은 <a class="reference external" href="http://docs.python.org/reference/compound_stmts.html#function">파이썬 함수 정의 문서</a> 참고.</p>
</dd>
<dt id="term-environ">환경(environ)<a class="headerlink" href="#term-environ" title="Permalink to this term">¶</a></dt><dd><p>루트 아래 모든 문서들에 대한 정보가 저장돼 있는 구조체이며
상호 참조에 사용한다. 파싱 단계 후에 환경을 pickle 하며,
그래서 이후 동작에선 새로 추가되거나 바뀐 문서만 읽어서
파싱하면 된다.</p>
</dd>
<dt id="term-0">핸들러 함수<a class="headerlink" href="#term-0" title="Permalink to this term">¶</a></dt><dd><p>특정 사건이나 상황을 처리하는 함수. 웹 프레임워크에선 응용을
구성하는 각 URL에 핸들러 함수를 콜백으로 붙이는 방식으로
응용을 개발한다.</p>
</dd>
<dt id="term-1">소스 디렉터리<a class="headerlink" href="#term-1" title="Permalink to this term">¶</a></dt><dd><p>스핑크스 프로젝트를 위한 모든 파일들을 담은 디렉터리 (하위 디렉터리 포함).</p>
</dd>
</dl>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Bottle</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">따라하기</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#installation">설치</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hello-world">빨리 해 보기: “Hello World”</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tutorial-routing">요청 라우팅</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tutorial-output">내용물 생성하기</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tutorial-request">요청 데이터</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tutorial-templates">템플릿</a></li>
<li class="toctree-l2"><a class="reference internal" href="#plugins">플러그인</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id30">개발</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id35">배치</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tutorial-glossary">용어</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="configuration.html">설정 (초안)</a></li>
<li class="toctree-l1"><a class="reference internal" href="routing.html">요청 라우팅</a></li>
<li class="toctree-l1"><a class="reference internal" href="stpl.html">SimpleTemplate 엔진</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API 참조</a></li>
<li class="toctree-l1"><a class="reference internal" href="plugins/index.html">사용 가능한 플러그인들</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="tutorial_app.html">따라하기: 할일 목록 응용</a></li>
<li class="toctree-l1"><a class="reference internal" href="async.html">비동기 응용 입문</a></li>
<li class="toctree-l1"><a class="reference internal" href="recipes.html">각종 해결법</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">자주 묻는 질문</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">릴리스 노트와 변경 로그</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html#id2">기여자</a></li>
<li class="toctree-l1"><a class="reference internal" href="development.html">개발자를 위해</a></li>
<li class="toctree-l1"><a class="reference internal" href="plugindev.html">플러그인 개발 안내서</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="plugins/index.html">사용 가능한 플러그인들</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">보틀: 파이썬 웹 프레임워크</a></li>
      <li>Next: <a href="configuration.html" title="next chapter">설정 (초안)</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2009-2021, Marcel Hellkamp.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.5.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/tutorial.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>